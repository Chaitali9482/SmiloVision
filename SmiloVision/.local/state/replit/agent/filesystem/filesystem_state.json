{"file_contents":{"attached_assets/main_1762359913548.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"matplotlib>=3.10.7\",\n    \"numpy>=2.3.4\",\n    \"opencv-python>=4.11.0.86\",\n    \"pandas>=2.3.3\",\n    \"pillow>=12.0.0\",\n    \"plotly>=6.4.0\",\n    \"reportlab>=4.4.4\",\n    \"scikit-image>=0.25.2\",\n    \"streamlit>=1.51.0\",\n]\n","size_bytes":363},"attached_assets/image_analyzer_1762359913549.py":{"content":"import cv2\nimport numpy as np\nfrom PIL import Image\nfrom skimage import filters, morphology, measure\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle, Ellipse\nimport io\n\nclass TeethAnalyzer:\n    def __init__(self):\n        self.blur_threshold = 100\n        self.brightness_min = 50\n        self.brightness_max = 200\n        \n    def check_image_quality(self, img_array):\n        \"\"\"Check image quality for lighting, blur, and framing\"\"\"\n        \n        # Convert to grayscale for analysis\n        if len(img_array.shape) == 3:\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        else:\n            gray = img_array\n            \n        # Check lighting\n        avg_brightness = np.mean(gray)\n        lighting_ok = self.brightness_min < avg_brightness < self.brightness_max\n        \n        # Check blur using Laplacian variance\n        blur_score = cv2.Laplacian(gray, cv2.CV_64F).var()\n        blur_ok = blur_score > self.blur_threshold\n        \n        # Check framing (simplified - check if center region has enough contrast)\n        h, w = gray.shape\n        center_region = gray[h//4:3*h//4, w//4:3*w//4]\n        contrast = np.std(center_region)\n        framing_ok = contrast > 20\n        \n        return {\n            'lighting_ok': lighting_ok,\n            'blur_ok': blur_ok,\n            'framing_ok': framing_ok,\n            'brightness': avg_brightness,\n            'blur_score': blur_score,\n            'contrast': contrast\n        }\n    \n    def analyze_teeth(self, img_array):\n        \"\"\"Comprehensive teeth analysis\"\"\"\n        \n        # Preprocessing\n        processed_img = self.preprocess_image(img_array)\n        \n        # Extract teeth region\n        teeth_mask = self.extract_teeth_region(processed_img)\n        \n        # Perform individual analyses\n        yellowness_score = self.detect_yellowness(processed_img, teeth_mask)\n        cavity_score = self.detect_cavities(processed_img, teeth_mask)\n        alignment_score = self.evaluate_alignment(processed_img, teeth_mask)\n        \n        # Calculate overall score\n        overall_score = self.calculate_overall_score(\n            yellowness_score, cavity_score, alignment_score)\n        \n        return {\n            'overall_score': overall_score,\n            'yellowness_score': yellowness_score,\n            'cavity_score': cavity_score,\n            'alignment_score': alignment_score,\n            'teeth_mask': teeth_mask,\n            'processed_image': processed_img\n        }\n    \n    def preprocess_image(self, img_array):\n        \"\"\"Preprocess image for analysis\"\"\"\n        \n        # Convert to RGB if needed\n        if len(img_array.shape) == 3 and img_array.shape[2] == 3:\n            img_rgb = img_array\n        else:\n            img_rgb = cv2.cvtColor(img_array, cv2.COLOR_BGR2RGB)\n        \n        # Apply CLAHE for contrast enhancement\n        lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)\n        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n        lab[:,:,0] = clahe.apply(lab[:,:,0])\n        enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n        \n        # Gamma correction for brightness normalization\n        gamma = 1.2\n        enhanced = np.power(enhanced / 255.0, gamma) * 255.0\n        enhanced = enhanced.astype(np.uint8)\n        \n        return enhanced\n    \n    def extract_teeth_region(self, img_array):\n        \"\"\"Extract teeth region using color-based segmentation\"\"\"\n        \n        # Convert to HSV for better color segmentation\n        hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n        \n        # Define range for teeth color (white/off-white/yellow tones)\n        lower_teeth = np.array([0, 0, 100])\n        upper_teeth = np.array([30, 100, 255])\n        \n        # Create mask for teeth\n        teeth_mask = cv2.inRange(hsv, lower_teeth, upper_teeth)\n        \n        # Morphological operations to clean up mask\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n        teeth_mask = cv2.morphologyEx(teeth_mask, cv2.MORPH_OPEN, kernel)\n        teeth_mask = cv2.morphologyEx(teeth_mask, cv2.MORPH_CLOSE, kernel)\n        \n        # Find largest contour (main teeth region)\n        contours, _ = cv2.findContours(teeth_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        if contours:\n            # Get the largest contour\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create refined mask\n            refined_mask = np.zeros_like(teeth_mask)\n            cv2.fillPoly(refined_mask, [largest_contour], 255)\n            \n            return refined_mask\n        \n        return teeth_mask\n    \n    def detect_yellowness(self, img_array, teeth_mask):\n        \"\"\"Detect yellow staining on teeth\"\"\"\n        \n        # Convert to HSV\n        hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n        \n        # Define yellow color range\n        lower_yellow = np.array([15, 50, 50])\n        upper_yellow = np.array([35, 255, 255])\n        \n        # Create yellow mask\n        yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n        \n        # Combine with teeth mask\n        yellow_on_teeth = cv2.bitwise_and(yellow_mask, teeth_mask)\n        \n        # Calculate yellowness percentage\n        teeth_pixels = np.sum(teeth_mask > 0)\n        yellow_pixels = np.sum(yellow_on_teeth > 0)\n        \n        if teeth_pixels > 0:\n            yellowness_percentage = (yellow_pixels / teeth_pixels) * 100\n        else:\n            yellowness_percentage = 0\n            \n        return min(yellowness_percentage, 100)\n    \n    def detect_cavities(self, img_array, teeth_mask):\n        \"\"\"Detect potential cavities (dark spots)\"\"\"\n        \n        # Convert to grayscale\n        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        \n        # Apply teeth mask\n        masked_gray = cv2.bitwise_and(gray, teeth_mask)\n        \n        # Find dark regions (potential cavities)\n        adaptive_thresh = cv2.adaptiveThreshold(\n            masked_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \n            cv2.THRESH_BINARY_INV, 11, 2)\n        \n        # Remove noise with morphological operations\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\n        cleaned = cv2.morphologyEx(adaptive_thresh, cv2.MORPH_OPEN, kernel)\n        \n        # Find contours of dark spots\n        contours, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        # Filter contours by size (cavity-like dimensions)\n        cavity_contours = []\n        for contour in contours:\n            area = cv2.contourArea(contour)\n            if 10 < area < 500:\n                cavity_contours.append(contour)\n        \n        # Calculate cavity risk percentage\n        teeth_pixels = np.sum(teeth_mask > 0)\n        cavity_pixels = sum([cv2.contourArea(c) for c in cavity_contours])\n        \n        if teeth_pixels > 0:\n            cavity_percentage = (cavity_pixels / teeth_pixels) * 100\n        else:\n            cavity_percentage = 0\n            \n        return min(cavity_percentage, 100)\n    \n    def evaluate_alignment(self, img_array, teeth_mask):\n        \"\"\"Evaluate teeth alignment\"\"\"\n        \n        # Convert to grayscale\n        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        \n        # Apply teeth mask\n        masked_gray = cv2.bitwise_and(gray, teeth_mask)\n        \n        # Find edges of teeth\n        edges = cv2.Canny(masked_gray, 50, 150)\n        \n        # Find contours\n        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        if not contours:\n            return 50\n        \n        # Get the main teeth contour\n        main_contour = max(contours, key=cv2.contourArea)\n        \n        # Fit an ellipse to the contour to represent ideal alignment\n        if len(main_contour) >= 5:\n            ellipse = cv2.fitEllipse(main_contour)\n            \n            # Simplified alignment scoring based on contour regularity\n            hull = cv2.convexHull(main_contour)\n            hull_area = cv2.contourArea(hull)\n            contour_area = cv2.contourArea(main_contour)\n            \n            if hull_area > 0:\n                convexity = contour_area / hull_area\n                alignment_score = convexity * 100\n            else:\n                alignment_score = 50\n        else:\n            alignment_score = 50\n            \n        return min(max(alignment_score, 0), 100)\n    \n    def calculate_overall_score(self, yellowness, cavity_risk, alignment):\n        \"\"\"Calculate overall oral health score\"\"\"\n        \n        # Weights for different factors\n        yellowness_weight = 0.3\n        cavity_weight = 0.5\n        alignment_weight = 0.2\n        \n        # Convert scores to positive scale (higher = better)\n        whiteness_score = 100 - yellowness\n        cavity_health_score = 100 - cavity_risk\n        \n        # Weighted average\n        overall = (\n            whiteness_score * yellowness_weight +\n            cavity_health_score * cavity_weight +\n            alignment * alignment_weight\n        )\n        \n        return min(max(overall, 0), 100)\n    \n    def create_visual_overlay(self, img_array, analysis_results):\n        \"\"\"Create visual overlay showing detected issues\"\"\"\n        \n        # Create a copy of the original image\n        overlay_img = img_array.copy()\n        \n        # Create figure for matplotlib overlay\n        fig, ax = plt.subplots(1, 1, figsize=(10, 8))\n        ax.imshow(overlay_img)\n        ax.set_title(\"Teeth Analysis Results\", fontsize=16, fontweight='bold')\n        \n        # Get image dimensions\n        height, width = img_array.shape[:2]\n        \n        # Overlay yellowness (yellow transparent regions)\n        if analysis_results['yellowness_score'] > 10:\n            # Convert to HSV to find yellow regions\n            hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n            lower_yellow = np.array([15, 50, 50])\n            upper_yellow = np.array([35, 255, 255])\n            yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n            \n            # Apply teeth mask\n            teeth_mask = analysis_results['teeth_mask']\n            yellow_on_teeth = cv2.bitwise_and(yellow_mask, teeth_mask)\n            \n            # Create yellow overlay\n            yellow_overlay = np.zeros_like(overlay_img)\n            yellow_overlay[yellow_on_teeth > 0] = [255, 255, 0]\n            \n            # Blend with original\n            alpha = 0.3\n            overlay_img = cv2.addWeighted(overlay_img, 1-alpha, yellow_overlay, alpha, 0)\n        \n        # Overlay cavity indicators (red circles)\n        if analysis_results['cavity_score'] > 5:\n            # Find dark spots as potential cavities\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n            masked_gray = cv2.bitwise_and(gray, analysis_results['teeth_mask'])\n            \n            # Adaptive threshold to find dark spots\n            adaptive_thresh = cv2.adaptiveThreshold(\n                masked_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, \n                cv2.THRESH_BINARY_INV, 11, 2)\n            \n            contours, _ = cv2.findContours(adaptive_thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n            \n            # Draw circles around potential cavities\n            for contour in contours:\n                area = cv2.contourArea(contour)\n                if 10 < area < 500:\n                    # Get centroid\n                    M = cv2.moments(contour)\n                    if M[\"m00\"] != 0:\n                        cx = int(M[\"m10\"] / M[\"m00\"])\n                        cy = int(M[\"m01\"] / M[\"m00\"])\n                        \n                        # Draw circle\n                        circle = Circle((cx, cy), radius=15, fill=False, \n                                      color='red', linewidth=3, alpha=0.8)\n                        ax.add_patch(circle)\n        \n        # Overlay alignment indicators (blue outlines)\n        if analysis_results['alignment_score'] < 80:\n            # Find main teeth contour\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n            masked_gray = cv2.bitwise_and(gray, analysis_results['teeth_mask'])\n            edges = cv2.Canny(masked_gray, 50, 150)\n            contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n            \n            if contours:\n                main_contour = max(contours, key=cv2.contourArea)\n                \n                # Draw contour outline in blue\n                contour_points = main_contour.reshape(-1, 2)\n                if len(contour_points) > 0:\n                    ax.plot(contour_points[:, 0], contour_points[:, 1], \n                           'b-', linewidth=2, alpha=0.7, label='Alignment Guide')\n        \n        # Add legend\n        legend_elements = []\n        if analysis_results['yellowness_score'] > 10:\n            legend_elements.append(plt.Line2D([0], [0], color='yellow', lw=4, alpha=0.7, label='Staining'))\n        if analysis_results['cavity_score'] > 5:\n            legend_elements.append(plt.Line2D([0], [0], marker='o', color='red', lw=0, \n                                            markersize=10, alpha=0.8, label='Potential Cavities'))\n        if analysis_results['alignment_score'] < 80:\n            legend_elements.append(plt.Line2D([0], [0], color='blue', lw=2, alpha=0.7, label='Alignment Issues'))\n        \n        if legend_elements:\n            ax.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1, 1))\n        \n        # Remove axes\n        ax.axis('off')\n        \n        # Convert matplotlib figure to image\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', dpi=100)\n        plt.close(fig)\n        buf.seek(0)\n        \n        # Convert to PIL Image\n        pil_image = Image.open(buf)\n        \n        return pil_image\n","size_bytes":13859},"attached_assets/database_1762359913551.py":{"content":"import sqlite3\nimport json\nfrom datetime import datetime\nimport os\n\nclass Database:\n    def __init__(self, db_path=\"toothcheck.db\"):\n        self.db_path = db_path\n        self.init_database()\n    \n    def init_database(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Create scans table\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS scans (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                date TEXT NOT NULL,\n                overall_score REAL NOT NULL,\n                yellowness_score REAL NOT NULL,\n                cavity_score REAL NOT NULL,\n                alignment_score REAL NOT NULL,\n                analysis_data TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create user_progress table for rewards and achievements\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS user_progress (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                stars INTEGER DEFAULT 0,\n                coins INTEGER DEFAULT 0,\n                total_scans INTEGER DEFAULT 0,\n                last_scan_date TEXT,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create reminders table\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS reminders (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                reminder_type TEXT NOT NULL,\n                reminder_text TEXT NOT NULL,\n                scheduled_date TEXT NOT NULL,\n                is_active BOOLEAN DEFAULT 1,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        conn.commit()\n        conn.close()\n        \n        # Initialize user progress if doesn't exist\n        self.init_user_progress()\n    \n    def init_user_progress(self):\n        \"\"\"Initialize user progress record if it doesn't exist\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"SELECT COUNT(*) FROM user_progress\")\n        count = cursor.fetchone()[0]\n        \n        if count == 0:\n            cursor.execute(\"\"\"\n                INSERT INTO user_progress (stars, coins, total_scans)\n                VALUES (0, 0, 0)\n            \"\"\")\n            conn.commit()\n        \n        conn.close()\n    \n    def save_scan_results(self, results):\n        \"\"\"Save scan results to database\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Prepare data\n        date_str = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        analysis_data = json.dumps({\n            key: str(value) if not isinstance(value, (int, float, str, bool, type(None))) else value\n            for key, value in results.items() \n            if key not in ['overall_score', 'yellowness_score', 'cavity_score', 'alignment_score']\n        })\n        \n        # Insert scan record\n        cursor.execute(\"\"\"\n            INSERT INTO scans (date, overall_score, yellowness_score, cavity_score, \n                             alignment_score, analysis_data)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\", (\n            date_str,\n            results['overall_score'],\n            results['yellowness_score'],\n            results['cavity_score'],\n            results['alignment_score'],\n            analysis_data\n        ))\n        \n        # Update user progress\n        cursor.execute(\"\"\"\n            UPDATE user_progress \n            SET total_scans = total_scans + 1,\n                last_scan_date = ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = 1\n        \"\"\", (date_str,))\n        \n        conn.commit()\n        conn.close()\n        \n        return cursor.lastrowid\n    \n    def get_all_scans(self):\n        \"\"\"Get all scan results ordered by date\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score, yellowness_score, cavity_score, alignment_score\n            FROM scans\n            ORDER BY created_at ASC\n        \"\"\")\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'date': row[0],\n                'overall_score': row[1],\n                'yellowness_score': row[2],\n                'cavity_score': row[3],\n                'alignment_score': row[4]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_recent_scans(self, limit=5):\n        \"\"\"Get recent scan results\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score\n            FROM scans\n            ORDER BY created_at DESC\n            LIMIT ?\n        \"\"\", (limit,))\n        \n        results = []\n        for row in cursor.fetchall():\n            # Format date for display\n            date_obj = datetime.strptime(row[0], \"%Y-%m-%d %H:%M:%S\")\n            formatted_date = date_obj.strftime(\"%m/%d\")\n            \n            results.append({\n                'date': formatted_date,\n                'overall_score': row[1]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_user_progress(self):\n        \"\"\"Get user progress including stars and coins\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT stars, coins, total_scans, last_scan_date\n            FROM user_progress\n            WHERE id = 1\n        \"\"\")\n        \n        row = cursor.fetchone()\n        conn.close()\n        \n        if row:\n            return {\n                'stars': row[0],\n                'coins': row[1],\n                'total_scans': row[2],\n                'last_scan_date': row[3]\n            }\n        else:\n            return {'stars': 0, 'coins': 0, 'total_scans': 0, 'last_scan_date': None}\n    \n    def update_user_rewards(self, stars_earned=0, coins_earned=0):\n        \"\"\"Update user rewards (stars and coins)\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            UPDATE user_progress \n            SET stars = stars + ?, \n                coins = coins + ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = 1\n        \"\"\", (stars_earned, coins_earned))\n        \n        conn.commit()\n        conn.close()\n    \n    def get_progress_trends(self, days=30):\n        \"\"\"Get progress trends for the last N days\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score, yellowness_score, cavity_score, alignment_score\n            FROM scans\n            WHERE date >= date('now', '-{} days')\n            ORDER BY created_at ASC\n        \"\"\".format(days))\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'date': row[0],\n                'overall_score': row[1],\n                'yellowness_score': row[2],\n                'cavity_score': row[3],\n                'alignment_score': row[4]\n            })\n        \n        conn.close()\n        return results\n    \n    def save_reminder(self, reminder_type, reminder_text, scheduled_date):\n        \"\"\"Save a reminder\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            INSERT INTO reminders (reminder_type, reminder_text, scheduled_date)\n            VALUES (?, ?, ?)\n        \"\"\", (reminder_type, reminder_text, scheduled_date))\n        \n        conn.commit()\n        conn.close()\n        \n        return cursor.lastrowid\n    \n    def get_active_reminders(self):\n        \"\"\"Get all active reminders\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT id, reminder_type, reminder_text, scheduled_date\n            FROM reminders\n            WHERE is_active = 1\n            ORDER BY scheduled_date ASC\n        \"\"\")\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'id': row[0],\n                'type': row[1],\n                'text': row[2],\n                'date': row[3]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_stats_summary(self):\n        \"\"\"Get summary statistics\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Get total scans\n        cursor.execute(\"SELECT COUNT(*) FROM scans\")\n        total_scans = cursor.fetchone()[0]\n        \n        # Get average scores\n        cursor.execute(\"\"\"\n            SELECT AVG(overall_score), AVG(yellowness_score), \n                   AVG(cavity_score), AVG(alignment_score)\n            FROM scans\n        \"\"\")\n        \n        averages = cursor.fetchone()\n        \n        # Get latest scan\n        cursor.execute(\"\"\"\n            SELECT overall_score, date\n            FROM scans\n            ORDER BY created_at DESC\n            LIMIT 1\n        \"\"\")\n        \n        latest_scan = cursor.fetchone()\n        \n        # Get user progress\n        user_progress = self.get_user_progress()\n        \n        conn.close()\n        \n        return {\n            'total_scans': total_scans,\n            'avg_overall_score': averages[0] if averages[0] else 0,\n            'avg_yellowness_score': averages[1] if averages[1] else 0,\n            'avg_cavity_score': averages[2] if averages[2] else 0,\n            'avg_alignment_score': averages[3] if averages[3] else 0,\n            'latest_score': latest_scan[0] if latest_scan else 0,\n            'latest_date': latest_scan[1] if latest_scan else None,\n            'stars': user_progress['stars'],\n            'coins': user_progress['coins']\n        }\n    \n    def clear_all_data(self):\n        \"\"\"Clear all data (for testing/reset purposes)\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"DELETE FROM scans\")\n        cursor.execute(\"DELETE FROM reminders\")\n        cursor.execute(\"UPDATE user_progress SET stars=0, coins=0, total_scans=0, last_scan_date=NULL\")\n        \n        conn.commit()\n        conn.close()\n","size_bytes":10424},"database.py":{"content":"import sqlite3\nimport json\nfrom datetime import datetime\nimport os\n\nclass Database:\n    def __init__(self, db_path=\"smilo.db\"):\n        self.db_path = db_path\n        self.init_database()\n    \n    def init_database(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Create scans table\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS scans (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                date TEXT NOT NULL,\n                overall_score REAL NOT NULL,\n                yellowness_score REAL NOT NULL,\n                cavity_score REAL NOT NULL,\n                alignment_score REAL NOT NULL,\n                analysis_data TEXT,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create user_progress table for rewards and achievements\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS user_progress (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                stars INTEGER DEFAULT 0,\n                coins INTEGER DEFAULT 0,\n                total_scans INTEGER DEFAULT 0,\n                last_scan_date TEXT,\n                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        # Create reminders table\n        cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS reminders (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                reminder_type TEXT NOT NULL,\n                reminder_text TEXT NOT NULL,\n                scheduled_date TEXT NOT NULL,\n                is_active BOOLEAN DEFAULT 1,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\")\n        \n        conn.commit()\n        conn.close()\n        \n        # Initialize user progress if doesn't exist\n        self.init_user_progress()\n    \n    def init_user_progress(self):\n        \"\"\"Initialize user progress record if it doesn't exist\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"SELECT COUNT(*) FROM user_progress\")\n        count = cursor.fetchone()[0]\n        \n        if count == 0:\n            cursor.execute(\"\"\"\n                INSERT INTO user_progress (stars, coins, total_scans)\n                VALUES (0, 0, 0)\n            \"\"\")\n            conn.commit()\n        \n        conn.close()\n    \n    def save_scan_results(self, results):\n        \"\"\"Save scan results to database\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Prepare data\n        date_str = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        analysis_data = json.dumps({\n            key: str(value) if not isinstance(value, (int, float, str, bool, type(None))) else value\n            for key, value in results.items() \n            if key not in ['overall_score', 'yellowness_score', 'cavity_score', 'alignment_score']\n        })\n        \n        # Insert scan record\n        cursor.execute(\"\"\"\n            INSERT INTO scans (date, overall_score, yellowness_score, cavity_score, \n                             alignment_score, analysis_data)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\", (\n            date_str,\n            results['overall_score'],\n            results['yellowness_score'],\n            results['cavity_score'],\n            results['alignment_score'],\n            analysis_data\n        ))\n        \n        # Update user progress\n        cursor.execute(\"\"\"\n            UPDATE user_progress \n            SET total_scans = total_scans + 1,\n                last_scan_date = ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = 1\n        \"\"\", (date_str,))\n        \n        conn.commit()\n        conn.close()\n        \n        return cursor.lastrowid\n    \n    def get_all_scans(self):\n        \"\"\"Get all scan results ordered by date\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score, yellowness_score, cavity_score, alignment_score\n            FROM scans\n            ORDER BY created_at ASC\n        \"\"\")\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'date': row[0],\n                'overall_score': row[1],\n                'yellowness_score': row[2],\n                'cavity_score': row[3],\n                'alignment_score': row[4]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_recent_scans(self, limit=5):\n        \"\"\"Get recent scan results\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score\n            FROM scans\n            ORDER BY created_at DESC\n            LIMIT ?\n        \"\"\", (limit,))\n        \n        results = []\n        for row in cursor.fetchall():\n            # Format date for display\n            date_obj = datetime.strptime(row[0], \"%Y-%m-%d %H:%M:%S\")\n            formatted_date = date_obj.strftime(\"%m/%d\")\n            \n            results.append({\n                'date': formatted_date,\n                'overall_score': row[1]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_user_progress(self):\n        \"\"\"Get user progress including stars and coins\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT stars, coins, total_scans, last_scan_date\n            FROM user_progress\n            WHERE id = 1\n        \"\"\")\n        \n        row = cursor.fetchone()\n        conn.close()\n        \n        if row:\n            return {\n                'stars': row[0],\n                'coins': row[1],\n                'total_scans': row[2],\n                'last_scan_date': row[3]\n            }\n        else:\n            return {'stars': 0, 'coins': 0, 'total_scans': 0, 'last_scan_date': None}\n    \n    def update_user_rewards(self, stars_earned=0, coins_earned=0):\n        \"\"\"Update user rewards (stars and coins)\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            UPDATE user_progress \n            SET stars = stars + ?, \n                coins = coins + ?,\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = 1\n        \"\"\", (stars_earned, coins_earned))\n        \n        conn.commit()\n        conn.close()\n    \n    def get_progress_trends(self, days=30):\n        \"\"\"Get progress trends for the last N days\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT date, overall_score, yellowness_score, cavity_score, alignment_score\n            FROM scans\n            WHERE date >= date('now', '-{} days')\n            ORDER BY created_at ASC\n        \"\"\".format(days))\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'date': row[0],\n                'overall_score': row[1],\n                'yellowness_score': row[2],\n                'cavity_score': row[3],\n                'alignment_score': row[4]\n            })\n        \n        conn.close()\n        return results\n    \n    def save_reminder(self, reminder_type, reminder_text, scheduled_date):\n        \"\"\"Save a reminder\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            INSERT INTO reminders (reminder_type, reminder_text, scheduled_date)\n            VALUES (?, ?, ?)\n        \"\"\", (reminder_type, reminder_text, scheduled_date))\n        \n        conn.commit()\n        conn.close()\n        \n        return cursor.lastrowid\n    \n    def get_active_reminders(self):\n        \"\"\"Get all active reminders\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            SELECT id, reminder_type, reminder_text, scheduled_date\n            FROM reminders\n            WHERE is_active = 1\n            ORDER BY scheduled_date ASC\n        \"\"\")\n        \n        results = []\n        for row in cursor.fetchall():\n            results.append({\n                'id': row[0],\n                'type': row[1],\n                'text': row[2],\n                'date': row[3]\n            })\n        \n        conn.close()\n        return results\n    \n    def get_stats_summary(self):\n        \"\"\"Get summary statistics\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Get total scans\n        cursor.execute(\"SELECT COUNT(*) FROM scans\")\n        total_scans = cursor.fetchone()[0]\n        \n        # Get average scores\n        cursor.execute(\"\"\"\n            SELECT AVG(overall_score), AVG(yellowness_score), \n                   AVG(cavity_score), AVG(alignment_score)\n            FROM scans\n        \"\"\")\n        \n        averages = cursor.fetchone()\n        \n        # Get latest scan\n        cursor.execute(\"\"\"\n            SELECT overall_score, date\n            FROM scans\n            ORDER BY created_at DESC\n            LIMIT 1\n        \"\"\")\n        \n        latest_scan = cursor.fetchone()\n        \n        # Get user progress\n        user_progress = self.get_user_progress()\n        \n        conn.close()\n        \n        return {\n            'total_scans': total_scans,\n            'avg_overall_score': averages[0] if averages[0] else 0,\n            'avg_yellowness_score': averages[1] if averages[1] else 0,\n            'avg_cavity_score': averages[2] if averages[2] else 0,\n            'avg_alignment_score': averages[3] if averages[3] else 0,\n            'latest_score': latest_scan[0] if latest_scan else 0,\n            'latest_date': latest_scan[1] if latest_scan else None,\n            'stars': user_progress['stars'],\n            'coins': user_progress['coins']\n        }\n    \n    def clear_all_data(self):\n        \"\"\"Clear all data (for testing/reset purposes)\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        cursor.execute(\"DELETE FROM scans\")\n        cursor.execute(\"DELETE FROM reminders\")\n        cursor.execute(\"UPDATE user_progress SET stars=0, coins=0, total_scans=0, last_scan_date=NULL\")\n        \n        conn.commit()\n        conn.close()\n","size_bytes":10419},"attached_assets/report_generator_1762359913545.py":{"content":"from reportlab.lib.pagesizes import letter, A4\nfrom reportlab.lib import colors\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle\nfrom reportlab.platypus.flowables import PageBreak\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY\nfrom PIL import Image as PILImage\nimport io\nfrom datetime import datetime\nimport numpy as np\n\nclass ReportGenerator:\n    def __init__(self):\n        self.styles = getSampleStyleSheet()\n        self.setup_custom_styles()\n    \n    def setup_custom_styles(self):\n        \"\"\"Setup custom styles for the report\"\"\"\n        \n        # Title style\n        self.title_style = ParagraphStyle(\n            'CustomTitle',\n            parent=self.styles['Heading1'],\n            fontSize=24,\n            spaceAfter=30,\n            alignment=TA_CENTER,\n            textColor=colors.HexColor('#2C3E50')\n        )\n        \n        # Subtitle style\n        self.subtitle_style = ParagraphStyle(\n            'CustomSubtitle',\n            parent=self.styles['Heading2'],\n            fontSize=16,\n            spaceAfter=20,\n            alignment=TA_CENTER,\n            textColor=colors.HexColor('#34495E')\n        )\n        \n        # Section header style\n        self.section_style = ParagraphStyle(\n            'SectionHeader',\n            parent=self.styles['Heading3'],\n            fontSize=14,\n            spaceAfter=10,\n            textColor=colors.HexColor('#2980B9'),\n            borderWidth=1,\n            borderColor=colors.HexColor('#2980B9'),\n            borderPadding=5\n        )\n        \n        # Body text style\n        self.body_style = ParagraphStyle(\n            'CustomBody',\n            parent=self.styles['Normal'],\n            fontSize=11,\n            spaceAfter=10,\n            alignment=TA_JUSTIFY,\n            leftIndent=20\n        )\n        \n        # Tips style\n        self.tips_style = ParagraphStyle(\n            'TipsStyle',\n            parent=self.styles['Normal'],\n            fontSize=10,\n            spaceAfter=8,\n            leftIndent=30,\n            bulletIndent=10,\n            textColor=colors.HexColor('#27AE60')\n        )\n    \n    def generate_pdf_report(self, image_file, analysis_results):\n        \"\"\"Generate comprehensive PDF report\"\"\"\n        \n        # Create buffer for PDF\n        buffer = io.BytesIO()\n        \n        # Create document\n        doc = SimpleDocTemplate(\n            buffer,\n            pagesize=A4,\n            rightMargin=72,\n            leftMargin=72,\n            topMargin=72,\n            bottomMargin=18\n        )\n        \n        # Build story (content)\n        story = []\n        \n        # Add header\n        story.extend(self.create_header())\n        \n        # Add summary section\n        story.extend(self.create_summary_section(analysis_results))\n        \n        # Add image analysis\n        story.extend(self.create_image_section(image_file, analysis_results))\n        \n        # Add detailed results\n        story.extend(self.create_detailed_results(analysis_results))\n        \n        # Add recommendations\n        story.extend(self.create_recommendations_section(analysis_results))\n        \n        # Add footer\n        story.extend(self.create_footer())\n        \n        # Build PDF\n        doc.build(story)\n        \n        # Get PDF data\n        pdf_data = buffer.getvalue()\n        buffer.close()\n        \n        return pdf_data\n    \n    def create_header(self):\n        \"\"\"Create report header\"\"\"\n        story = []\n        \n        # Title\n        title = Paragraph(\"ToothCheck Analysis Report\", self.title_style)\n        story.append(title)\n        \n        # Date\n        date_str = datetime.now().strftime(\"%B %d, %Y at %I:%M %p\")\n        date_para = Paragraph(f\"Generated on {date_str}\", self.subtitle_style)\n        story.append(date_para)\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_summary_section(self, results):\n        \"\"\"Create executive summary section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Executive Summary\", self.section_style)\n        story.append(header)\n        \n        # Summary text\n        overall_score = results['overall_score']\n        \n        if overall_score >= 80:\n            summary_text = \"Excellent oral health detected! Your teeth show minimal issues and are in great condition.\"\n        elif overall_score >= 60:\n            summary_text = \"Good oral health with some areas for improvement. Regular maintenance recommended.\"\n        else:\n            summary_text = \"Your oral health needs attention. Consider consulting a dental professional.\"\n        \n        summary = Paragraph(summary_text, self.body_style)\n        story.append(summary)\n        \n        story.append(Spacer(1, 10))\n        \n        # Scores table\n        scores_data = [\n            ['Metric', 'Score', 'Status'],\n            ['Overall Health', f\"{overall_score:.1f}/100\", self.get_status_text(overall_score)],\n            ['Whiteness Level', f\"{100-results['yellowness_score']:.1f}/100\", \n             self.get_status_text(100-results['yellowness_score'])],\n            ['Cavity Health', f\"{100-results['cavity_score']:.1f}/100\", \n             self.get_status_text(100-results['cavity_score'])],\n            ['Alignment Score', f\"{results['alignment_score']:.1f}/100\", \n             self.get_status_text(results['alignment_score'])]\n        ]\n        \n        scores_table = Table(scores_data, colWidths=[2*inch, 1.5*inch, 1.5*inch])\n        scores_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498DB')),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, 0), 12),\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black)\n        ]))\n        \n        story.append(scores_table)\n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_image_section(self, image_file, results):\n        \"\"\"Create image analysis section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Visual Analysis\", self.section_style)\n        story.append(header)\n        \n        # Convert and resize image for PDF\n        try:\n            # Open original image\n            image_file.seek(0)\n            pil_image = PILImage.open(image_file)\n            \n            # Resize for PDF (max width 400px)\n            max_width = 400\n            if pil_image.width > max_width:\n                ratio = max_width / pil_image.width\n                new_height = int(pil_image.height * ratio)\n                pil_image = pil_image.resize((max_width, new_height), PILImage.LANCZOS)\n            \n            # Save to buffer\n            img_buffer = io.BytesIO()\n            pil_image.save(img_buffer, format='PNG')\n            img_buffer.seek(0)\n            \n            # Add to PDF\n            img = Image(img_buffer, width=4*inch, height=3*inch)\n            story.append(img)\n            \n        except Exception as e:\n            # If image processing fails, add placeholder text\n            img_error = Paragraph(\"Original image could not be processed for PDF inclusion.\", \n                                self.body_style)\n            story.append(img_error)\n        \n        story.append(Spacer(1, 10))\n        \n        # Image analysis description\n        analysis_desc = \"\"\"\n        The above image has been analyzed using advanced computer vision algorithms to detect:\n        <br/><br/>\n        - Yellow highlighting: Areas of staining or discoloration<br/>\n        - Red circles: Potential cavity locations<br/>\n        - Blue outlines: Alignment irregularities<br/>\n        \"\"\"\n        \n        desc_para = Paragraph(analysis_desc, self.body_style)\n        story.append(desc_para)\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_detailed_results(self, results):\n        \"\"\"Create detailed results section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Detailed Analysis Results\", self.section_style)\n        story.append(header)\n        \n        # Yellowness analysis\n        yellowness_header = Paragraph(\"Staining and Discoloration Analysis\", \n                                    ParagraphStyle('SubSection', parent=self.body_style, \n                                                 fontSize=12, textColor=colors.HexColor('#F39C12')))\n        story.append(yellowness_header)\n        \n        yellowness_text = f\"\"\"\n        Your teeth show {results['yellowness_score']:.1f}% staining or discoloration. \n        {self.get_yellowness_interpretation(results['yellowness_score'])}\n        \"\"\"\n        story.append(Paragraph(yellowness_text, self.body_style))\n        \n        story.append(Spacer(1, 10))\n        \n        # Cavity analysis\n        cavity_header = Paragraph(\"Cavity Risk Assessment\", \n                                ParagraphStyle('SubSection', parent=self.body_style, \n                                             fontSize=12, textColor=colors.HexColor('#E74C3C')))\n        story.append(cavity_header)\n        \n        cavity_text = f\"\"\"\n        Cavity risk level detected: {results['cavity_score']:.1f}%. \n        {self.get_cavity_interpretation(results['cavity_score'])}\n        \"\"\"\n        story.append(Paragraph(cavity_text, self.body_style))\n        \n        story.append(Spacer(1, 10))\n        \n        # Alignment analysis\n        alignment_header = Paragraph(\"Teeth Alignment Evaluation\", \n                                   ParagraphStyle('SubSection', parent=self.body_style, \n                                                fontSize=12, textColor=colors.HexColor('#3498DB')))\n        story.append(alignment_header)\n        \n        alignment_text = f\"\"\"\n        Alignment score: {results['alignment_score']:.1f}/100. \n        {self.get_alignment_interpretation(results['alignment_score'])}\n        \"\"\"\n        story.append(Paragraph(alignment_text, self.body_style))\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_recommendations_section(self, results):\n        \"\"\"Create personalized recommendations section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Personalized Recommendations\", self.section_style)\n        story.append(header)\n        \n        # Get recommendations based on results\n        recommendations = self.get_detailed_recommendations(results)\n        \n        for category, tips in recommendations.items():\n            # Category header\n            cat_header = Paragraph(f\"{category}\", \n                                 ParagraphStyle('Category', parent=self.body_style, \n                                              fontSize=12, textColor=colors.HexColor('#27AE60')))\n            story.append(cat_header)\n            \n            # Tips\n            for tip in tips:\n                tip_para = Paragraph(f\"  - {tip}\", self.tips_style)\n                story.append(tip_para)\n            \n            story.append(Spacer(1, 10))\n        \n        return story\n    \n    def create_footer(self):\n        \"\"\"Create report footer\"\"\"\n        story = []\n        \n        story.append(Spacer(1, 30))\n        \n        # Disclaimer\n        disclaimer = \"\"\"\n        <b>Important Disclaimer:</b> This analysis is provided by ToothCheck for informational \n        purposes only and should not replace professional dental care. Please consult with a \n        qualified dentist for comprehensive oral health evaluation and treatment recommendations.\n        \"\"\"\n        \n        disclaimer_para = Paragraph(disclaimer, \n                                  ParagraphStyle('Disclaimer', parent=self.body_style, \n                                               fontSize=9, textColor=colors.HexColor('#7F8C8D'),\n                                               alignment=TA_CENTER))\n        story.append(disclaimer_para)\n        \n        # Footer\n        footer_text = f\"\"\"\n        Generated by ToothCheck - AI-Powered Oral Health Screening<br/>\n        Report ID: TH-{datetime.now().strftime('%Y%m%d%H%M%S')}<br/>\n        Copyright 2024 ToothCheck. All rights reserved.\n        \"\"\"\n        \n        footer_para = Paragraph(footer_text, \n                              ParagraphStyle('Footer', parent=self.body_style, \n                                           fontSize=8, textColor=colors.HexColor('#95A5A6'),\n                                           alignment=TA_CENTER))\n        story.append(footer_para)\n        \n        return story\n    \n    def get_status_text(self, score):\n        \"\"\"Get status text based on score\"\"\"\n        if score >= 80:\n            return \"Excellent\"\n        elif score >= 60:\n            return \"Good\"\n        elif score >= 40:\n            return \"Fair\"\n        else:\n            return \"Needs Attention\"\n    \n    def get_yellowness_interpretation(self, score):\n        \"\"\"Get interpretation for yellowness score\"\"\"\n        if score <= 10:\n            return \"Minimal staining detected. Your teeth appear well-maintained.\"\n        elif score <= 25:\n            return \"Light staining present. Regular whitening routine may be beneficial.\"\n        elif score <= 50:\n            return \"Moderate staining detected. Consider professional whitening treatment.\"\n        else:\n            return \"Significant staining present. Professional dental cleaning and whitening recommended.\"\n    \n    def get_cavity_interpretation(self, score):\n        \"\"\"Get interpretation for cavity score\"\"\"\n        if score <= 5:\n            return \"Low cavity risk. Maintain current oral hygiene routine.\"\n        elif score <= 15:\n            return \"Moderate cavity risk detected. Monitor closely and maintain good oral hygiene.\"\n        elif score <= 30:\n            return \"Higher cavity risk identified. Dental examination recommended.\"\n        else:\n            return \"Significant cavity risk detected. Immediate dental consultation advised.\"\n    \n    def get_alignment_interpretation(self, score):\n        \"\"\"Get interpretation for alignment score\"\"\"\n        if score >= 85:\n            return \"Excellent teeth alignment. No concerns detected.\"\n        elif score >= 70:\n            return \"Good alignment with minor irregularities.\"\n        elif score >= 50:\n            return \"Moderate alignment issues. Consider orthodontic consultation.\"\n        else:\n            return \"Significant alignment concerns. Orthodontic evaluation recommended.\"\n    \n    def get_detailed_recommendations(self, results):\n        \"\"\"Get detailed recommendations based on analysis\"\"\"\n        recommendations = {}\n        \n        # Daily care recommendations\n        daily_care = [\n            \"Brush teeth twice daily for 2 minutes using fluoride toothpaste\",\n            \"Floss daily to remove plaque between teeth\",\n            \"Use an antimicrobial mouthwash to reduce bacteria\",\n            \"Replace toothbrush every 3-4 months or after illness\"\n        ]\n        \n        # Add specific recommendations based on results\n        if results['yellowness_score'] > 20:\n            daily_care.extend([\n                \"Consider whitening toothpaste for stain removal\",\n                \"Limit consumption of coffee, tea, and red wine\",\n                \"Rinse mouth with water after consuming staining foods\"\n            ])\n        \n        recommendations[\"Daily Oral Care\"] = daily_care\n        \n        # Professional care\n        professional_care = [\n            \"Schedule dental cleanings every 6 months\",\n            \"Annual comprehensive dental examination\",\n            \"Discuss fluoride treatments with your dentist\"\n        ]\n        \n        if results['cavity_score'] > 15:\n            professional_care.extend([\n                \"Schedule immediate dental examination for dark spots\",\n                \"Discuss preventive sealants with your dentist\"\n            ])\n        \n        if results['alignment_score'] < 70:\n            professional_care.append(\"Consider orthodontic consultation for alignment issues\")\n        \n        recommendations[\"Professional Care\"] = professional_care\n        \n        # Lifestyle recommendations\n        lifestyle = [\n            \"Maintain a balanced diet low in sugary snacks\",\n            \"Stay hydrated throughout the day\",\n            \"Avoid using teeth as tools (opening packages, etc.)\",\n            \"Consider using a night guard if you grind your teeth\"\n        ]\n        \n        recommendations[\"Lifestyle Adjustments\"] = lifestyle\n        \n        return recommendations\n","size_bytes":16842},"attached_assets/replit_1762359913546.md":{"content":"# ToothCheck - Dental Health Analysis Application\n\n## Overview\n\nToothCheck is a Streamlit-based web application that performs automated dental health analysis using computer vision. The application allows users to upload teeth images and receive comprehensive analysis reports covering aspects like tooth yellowness, cavity detection, and alignment scoring. It features a dual-mode interface (standard and kid-friendly) with a gamification system that rewards users with stars and coins for regular dental health monitoring.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n\n**Framework Choice: Streamlit**\n- **Rationale**: Streamlit provides rapid prototyping for data-driven applications with minimal frontend code\n- **Pros**: Fast development, built-in state management, easy data visualization integration\n- **Cons**: Limited customization compared to traditional web frameworks, server-side rendering only\n\n**State Management**\n- Uses Streamlit's native session state for maintaining application state across reruns\n- Key state variables: `current_screen`, `kid_mode`, `current_image`, `analysis_results`, `user_rewards`\n- Component instances (analyzer, report generator, database) are cached in session state for performance\n\n**UI Patterns**\n- Sidebar navigation for mode switching and main controls\n- Wide layout configuration for better image display\n- Dual-mode interface: standard mode for adults, kid mode with simplified language and gamification elements\n\n### Backend Architecture\n\n**Modular Component Design**\n- **TeethAnalyzer**: Handles all image processing and analysis logic using OpenCV and scikit-image\n- **ReportGenerator**: Creates PDF reports using ReportLab with custom styling\n- **Database**: Manages data persistence and retrieval operations\n- **Rationale**: Separation of concerns allows independent testing and maintenance of each module\n\n**Image Processing Pipeline**\n- Quality checks (lighting, blur, framing) before analysis\n- Multi-metric analysis system: yellowness detection, cavity scoring, alignment assessment\n- Uses computer vision techniques: Laplacian variance for blur detection, grayscale conversion, contrast analysis\n- **Chosen approach**: OpenCV + scikit-image combination provides robust image processing capabilities\n\n**Analysis Scoring System**\n- Individual scores for yellowness, cavities, and alignment\n- Overall composite score calculation\n- Thresholds configured for quality gates (blur_threshold: 100, brightness range: 50-200)\n\n### Data Storage\n\n**Database: SQLite**\n- **Rationale**: Lightweight, serverless, requires no configuration - ideal for single-user desktop/web application\n- **Schema Design**:\n  - `scans`: Stores historical scan data with scores and analysis metadata\n  - `user_progress`: Tracks gamification metrics (stars, coins, total scans)\n  - `reminders`: Manages scheduled dental care reminders\n- **Data Serialization**: JSON format for complex analysis_data storage within SQLite\n\n**Session State vs Persistent Storage**\n- Transient data (current image, active analysis) stored in Streamlit session state\n- Historical data and user progress persisted to SQLite\n- **Trade-off**: Session state provides fast access but requires database sync for persistence\n\n### Report Generation\n\n**PDF Generation: ReportLab**\n- Custom styled reports with headers, tables, and embedded images\n- Predefined styles for consistency (CustomTitle, CustomSubtitle, SectionHeader)\n- Support for multiple page sizes (Letter, A4)\n- **Alternative considered**: HTML/CSS reports, rejected due to less precise formatting control\n\n### Gamification System\n\n**Reward Mechanism**\n- Stars and coins awarded for scan completions\n- Progress tracking with last_scan_date to encourage regular use\n- Integration with database for persistent reward state\n- **Purpose**: Increase user engagement, particularly effective in kid mode\n\n## External Dependencies\n\n### Core Python Libraries\n\n**Computer Vision & Image Processing**\n- `opencv-python (cv2)`: Primary image processing, quality checks, blur detection\n- `scikit-image`: Advanced morphological operations, filtering, measurements\n- `Pillow (PIL)`: Image format conversions and basic manipulations\n- `numpy`: Array operations and numerical computations for image data\n\n**Visualization**\n- `matplotlib`: Static plot generation for analysis visualizations\n- `plotly`: Interactive charts (express and graph_objects) for progress tracking\n- `streamlit`: Web application framework and UI components\n\n**Report Generation**\n- `reportlab`: PDF creation with custom styling and layouts\n\n**Data Management**\n- `pandas`: Data manipulation for historical scan data and progress tracking\n- `sqlite3`: Built-in Python library for database operations\n\n**Utilities**\n- `datetime`: Timestamp management for scans and reminders\n- `json`: Serialization of complex analysis data\n- `base64`: Image encoding for data transfer\n- `io.BytesIO`: In-memory file operations\n\n### Database\n\n**SQLite (Local File-Based)**\n- Database file: `toothcheck.db`\n- No external database server required\n- Suitable for single-user deployment\n- Migration path available if multi-user support needed (could migrate to PostgreSQL)\n\n### File System Dependencies\n\n**Local Storage**\n- Temporary image storage during analysis\n- PDF report output location\n- Database file persistence\n- No cloud storage integration in current implementation","size_bytes":5458},"report_generator.py":{"content":"from reportlab.lib.pagesizes import letter, A4\nfrom reportlab.lib import colors\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.units import inch\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle\nfrom reportlab.platypus.flowables import PageBreak\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_JUSTIFY\nfrom PIL import Image as PILImage\nimport io\nfrom datetime import datetime\nimport numpy as np\n\nclass ReportGenerator:\n    def __init__(self):\n        self.styles = getSampleStyleSheet()\n        self.setup_custom_styles()\n    \n    def setup_custom_styles(self):\n        \"\"\"Setup custom styles for the report\"\"\"\n        \n        # Title style with Smilo branding color\n        self.title_style = ParagraphStyle(\n            'CustomTitle',\n            parent=self.styles['Heading1'],\n            fontSize=24,\n            spaceAfter=30,\n            alignment=TA_CENTER,\n            textColor=colors.HexColor('#4A90E2')\n        )\n        \n        # Subtitle style\n        self.subtitle_style = ParagraphStyle(\n            'CustomSubtitle',\n            parent=self.styles['Heading2'],\n            fontSize=16,\n            spaceAfter=20,\n            alignment=TA_CENTER,\n            textColor=colors.HexColor('#34495E')\n        )\n        \n        # Section header style\n        self.section_style = ParagraphStyle(\n            'SectionHeader',\n            parent=self.styles['Heading3'],\n            fontSize=14,\n            spaceAfter=10,\n            textColor=colors.HexColor('#4A90E2'),\n            borderWidth=1,\n            borderColor=colors.HexColor('#4A90E2'),\n            borderPadding=5\n        )\n        \n        # Body text style\n        self.body_style = ParagraphStyle(\n            'CustomBody',\n            parent=self.styles['Normal'],\n            fontSize=11,\n            spaceAfter=10,\n            alignment=TA_JUSTIFY,\n            leftIndent=20\n        )\n        \n        # Tips style\n        self.tips_style = ParagraphStyle(\n            'TipsStyle',\n            parent=self.styles['Normal'],\n            fontSize=10,\n            spaceAfter=8,\n            leftIndent=30,\n            bulletIndent=10,\n            textColor=colors.HexColor('#27AE60')\n        )\n    \n    def generate_pdf_report(self, image_file, analysis_results):\n        \"\"\"Generate comprehensive PDF report\"\"\"\n        \n        # Create buffer for PDF\n        buffer = io.BytesIO()\n        \n        # Create document\n        doc = SimpleDocTemplate(\n            buffer,\n            pagesize=A4,\n            rightMargin=72,\n            leftMargin=72,\n            topMargin=72,\n            bottomMargin=18\n        )\n        \n        # Build story (content)\n        story = []\n        \n        # Add header\n        story.extend(self.create_header())\n        \n        # Add summary section\n        story.extend(self.create_summary_section(analysis_results))\n        \n        # Add image analysis\n        story.extend(self.create_image_section(image_file, analysis_results))\n        \n        # Add detailed results\n        story.extend(self.create_detailed_results(analysis_results))\n        \n        # Add recommendations\n        story.extend(self.create_recommendations_section(analysis_results))\n        \n        # Add footer\n        story.extend(self.create_footer())\n        \n        # Build PDF\n        doc.build(story)\n        \n        # Get PDF data\n        pdf_data = buffer.getvalue()\n        buffer.close()\n        \n        return pdf_data\n    \n    def create_header(self):\n        \"\"\"Create report header\"\"\"\n        story = []\n        \n        # Title\n        title = Paragraph(\" Smilo Dental Analysis Report\", self.title_style)\n        story.append(title)\n        \n        # Date\n        date_str = datetime.now().strftime(\"%B %d, %Y at %I:%M %p\")\n        date_para = Paragraph(f\"Generated on {date_str}\", self.subtitle_style)\n        story.append(date_para)\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_summary_section(self, results):\n        \"\"\"Create executive summary section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Executive Summary\", self.section_style)\n        story.append(header)\n        \n        # Summary text with proper interpretation\n        overall_score = results['overall_score']\n        yellowness = results['yellowness_score']\n        cavity = results['cavity_score']\n        alignment = results['alignment_score']\n        \n        if overall_score >= 85:\n            summary_text = \"Excellent oral health! Your teeth show minimal issues and are in great condition. Keep up the outstanding work with your dental care routine.\"\n        elif overall_score >= 70:\n            summary_text = \"Very good oral health with only minor areas for improvement. Your dental hygiene is working well, continue with regular maintenance.\"\n        elif overall_score >= 55:\n            summary_text = \"Good oral health with some areas that need attention. Regular dental care and following the recommendations below will help improve your smile.\"\n        else:\n            summary_text = \"Your oral health needs attention in several areas. Please review the detailed findings and recommendations below, and consider scheduling a dental consultation.\"\n        \n        summary = Paragraph(summary_text, self.body_style)\n        story.append(summary)\n        \n        story.append(Spacer(1, 10))\n        \n        # Scores table\n        scores_data = [\n            ['Metric', 'Score', 'Status'],\n            ['Overall Health', f\"{overall_score:.1f}/100\", self.get_status_text(overall_score)],\n            ['Whiteness Level', f\"{100-yellowness:.1f}/100\", self.get_status_text(100-yellowness)],\n            ['Cavity Health', f\"{100-cavity:.1f}/100\", self.get_status_text(100-cavity)],\n            ['Alignment Score', f\"{alignment:.1f}/100\", self.get_status_text(alignment)]\n        ]\n        \n        scores_table = Table(scores_data, colWidths=[2*inch, 1.5*inch, 1.5*inch])\n        scores_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4A90E2')),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, 0), 12),\n            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),\n            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black)\n        ]))\n        \n        story.append(scores_table)\n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_image_section(self, image_file, results):\n        \"\"\"Create image analysis section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Visual Analysis\", self.section_style)\n        story.append(header)\n        \n        # Convert and resize image for PDF\n        try:\n            # Open original image\n            image_file.seek(0)\n            pil_image = PILImage.open(image_file)\n            \n            # Resize for PDF (max width 400px)\n            max_width = 400\n            if pil_image.width > max_width:\n                ratio = max_width / pil_image.width\n                new_height = int(pil_image.height * ratio)\n                pil_image = pil_image.resize((max_width, new_height), PILImage.LANCZOS)\n            \n            # Save to buffer\n            img_buffer = io.BytesIO()\n            pil_image.save(img_buffer, format='PNG')\n            img_buffer.seek(0)\n            \n            # Add to PDF\n            img = Image(img_buffer, width=4*inch, height=3*inch)\n            story.append(img)\n            \n        except Exception as e:\n            # If image processing fails, add placeholder text\n            img_error = Paragraph(\"Original image could not be processed for PDF inclusion.\", \n                                self.body_style)\n            story.append(img_error)\n        \n        story.append(Spacer(1, 10))\n        \n        # Image analysis description\n        analysis_desc = \"\"\"\n        The image has been analyzed using advanced computer vision algorithms to detect:\n        <br/><br/>\n        - Yellow overlay: Areas of staining or discoloration<br/>\n        - Red circles: Potential cavity locations or dark spots<br/>\n        - Blue outlines: Alignment irregularities<br/>\n        \"\"\"\n        \n        desc_para = Paragraph(analysis_desc, self.body_style)\n        story.append(desc_para)\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_detailed_results(self, results):\n        \"\"\"Create detailed results section with accurate interpretations\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Detailed Analysis Results\", self.section_style)\n        story.append(header)\n        \n        # Yellowness analysis\n        yellowness_header = Paragraph(\"Staining and Discoloration Analysis\", \n                                    ParagraphStyle('SubSection', parent=self.body_style, \n                                                 fontSize=12, textColor=colors.HexColor('#F39C12')))\n        story.append(yellowness_header)\n        \n        yellowness_text = f\"\"\"\n        Staining level detected: {results['yellowness_score']:.1f}%. \n        {self.get_yellowness_interpretation(results['yellowness_score'])}\n        \"\"\"\n        story.append(Paragraph(yellowness_text, self.body_style))\n        \n        story.append(Spacer(1, 10))\n        \n        # Cavity analysis\n        cavity_header = Paragraph(\"Cavity Risk Assessment\", \n                                ParagraphStyle('SubSection', parent=self.body_style, \n                                             fontSize=12, textColor=colors.HexColor('#E74C3C')))\n        story.append(cavity_header)\n        \n        cavity_text = f\"\"\"\n        Dark spot coverage: {results['cavity_score']:.1f}%. \n        {self.get_cavity_interpretation(results['cavity_score'])}\n        \"\"\"\n        story.append(Paragraph(cavity_text, self.body_style))\n        \n        story.append(Spacer(1, 10))\n        \n        # Alignment analysis\n        alignment_header = Paragraph(\"Teeth Alignment Evaluation\", \n                                   ParagraphStyle('SubSection', parent=self.body_style, \n                                                fontSize=12, textColor=colors.HexColor('#3498DB')))\n        story.append(alignment_header)\n        \n        alignment_text = f\"\"\"\n        Alignment score: {results['alignment_score']:.1f}/100. \n        {self.get_alignment_interpretation(results['alignment_score'])}\n        \"\"\"\n        story.append(Paragraph(alignment_text, self.body_style))\n        \n        story.append(Spacer(1, 20))\n        \n        return story\n    \n    def create_recommendations_section(self, results):\n        \"\"\"Create personalized recommendations section\"\"\"\n        story = []\n        \n        # Section header\n        header = Paragraph(\"Personalized Recommendations\", self.section_style)\n        story.append(header)\n        \n        # Get recommendations based on results\n        recommendations = self.get_detailed_recommendations(results)\n        \n        for category, tips in recommendations.items():\n            # Category header\n            cat_header = Paragraph(f\"{category}\", \n                                 ParagraphStyle('Category', parent=self.body_style, \n                                              fontSize=12, textColor=colors.HexColor('#27AE60')))\n            story.append(cat_header)\n            \n            # Tips\n            for tip in tips:\n                tip_para = Paragraph(f\"   {tip}\", self.tips_style)\n                story.append(tip_para)\n            \n            story.append(Spacer(1, 10))\n        \n        return story\n    \n    def create_footer(self):\n        \"\"\"Create report footer\"\"\"\n        story = []\n        \n        story.append(Spacer(1, 30))\n        \n        # Disclaimer\n        disclaimer = \"\"\"\n        <b>Important Disclaimer:</b> This analysis is provided by Smilo for informational \n        purposes only and should not replace professional dental care. Please consult with a \n        qualified dentist for comprehensive oral health evaluation and treatment recommendations.\n        \"\"\"\n        \n        disclaimer_para = Paragraph(disclaimer, \n                                  ParagraphStyle('Disclaimer', parent=self.body_style, \n                                               fontSize=9, textColor=colors.HexColor('#7F8C8D'),\n                                               alignment=TA_CENTER))\n        story.append(disclaimer_para)\n        \n        # Footer\n        footer_text = f\"\"\"\n        Generated by Smilo - AI-Powered Smile Analysis<br/>\n        Report ID: SM-{datetime.now().strftime('%Y%m%d%H%M%S')}<br/>\n        Copyright 2025 Smilo. All rights reserved.\n        \"\"\"\n        \n        footer_para = Paragraph(footer_text, \n                              ParagraphStyle('Footer', parent=self.body_style, \n                                           fontSize=8, textColor=colors.HexColor('#95A5A6'),\n                                           alignment=TA_CENTER))\n        story.append(footer_para)\n        \n        return story\n    \n    def get_status_text(self, score):\n        \"\"\"Get status text based on score\"\"\"\n        if score >= 85:\n            return \"Excellent\"\n        elif score >= 70:\n            return \"Very Good\"\n        elif score >= 55:\n            return \"Good\"\n        elif score >= 40:\n            return \"Fair\"\n        else:\n            return \"Needs Attention\"\n    \n    def get_yellowness_interpretation(self, score):\n        \"\"\"Get accurate interpretation for yellowness score\"\"\"\n        if score <= 5:\n            return \"Excellent! Minimal to no staining detected. Your teeth appear bright and well-maintained.\"\n        elif score <= 15:\n            return \"Very good whiteness with only slight staining. Continue your current oral care routine.\"\n        elif score <= 30:\n            return \"Light to moderate staining present. A whitening toothpaste or routine may be beneficial.\"\n        elif score <= 50:\n            return \"Moderate staining detected. Consider professional whitening treatment for best results.\"\n        else:\n            return \"Significant staining present. Professional dental cleaning and whitening treatment recommended.\"\n    \n    def get_cavity_interpretation(self, score):\n        \"\"\"Get accurate interpretation for cavity score\"\"\"\n        if score <= 2:\n            return \"Excellent! No significant dark spots detected. Maintain your current oral hygiene routine.\"\n        elif score <= 8:\n            return \"Low cavity risk. A few minor dark areas detected. Monitor and maintain good oral hygiene.\"\n        elif score <= 15:\n            return \"Moderate dark spot coverage. Schedule a dental checkup to evaluate these areas.\"\n        elif score <= 25:\n            return \"Notable dark spots detected. Dental examination recommended to assess potential cavities.\"\n        else:\n            return \"Multiple dark spots identified. Immediate dental consultation strongly advised for evaluation.\"\n    \n    def get_alignment_interpretation(self, score):\n        \"\"\"Get accurate interpretation for alignment score\"\"\"\n        if score >= 85:\n            return \"Excellent teeth alignment. No significant irregularities detected.\"\n        elif score >= 70:\n            return \"Very good alignment with minor irregularities that don't require intervention.\"\n        elif score >= 55:\n            return \"Good alignment with some noticeable irregularities. Monitoring recommended.\"\n        elif score >= 40:\n            return \"Moderate alignment issues detected. Consider orthodontic consultation.\"\n        else:\n            return \"Significant alignment concerns identified. Orthodontic evaluation recommended.\"\n    \n    def get_detailed_recommendations(self, results):\n        \"\"\"Get detailed recommendations based on actual analysis results\"\"\"\n        recommendations = {}\n        \n        # Daily care recommendations\n        daily_care = [\n            \"Brush teeth twice daily for 2 minutes using fluoride toothpaste\",\n            \"Floss daily to remove plaque between teeth\",\n            \"Use an antimicrobial mouthwash to reduce bacteria\"\n        ]\n        \n        # Add specific recommendations based on yellowness\n        if results['yellowness_score'] > 30:\n            daily_care.extend([\n                \"Use whitening toothpaste specifically designed for stain removal\",\n                \"Limit consumption of coffee, tea, red wine, and dark sodas\",\n                \"Rinse mouth with water immediately after consuming staining foods\",\n                \"Consider an electric toothbrush for more effective cleaning\"\n            ])\n        elif results['yellowness_score'] > 15:\n            daily_care.extend([\n                \"Consider whitening toothpaste for gentle stain removal\",\n                \"Be mindful of staining beverages and use a straw when possible\"\n            ])\n        \n        recommendations[\"Daily Oral Care\"] = daily_care\n        \n        # Professional care\n        professional_care = []\n        \n        if results['cavity_score'] > 15:\n            professional_care.extend([\n                \"Schedule dental examination within 1-2 weeks to evaluate dark spots\",\n                \"Discuss preventive sealants and fluoride treatments\",\n                \"Ask about professional deep cleaning procedures\"\n            ])\n        elif results['cavity_score'] > 8:\n            professional_care.extend([\n                \"Schedule routine dental checkup to monitor dark areas\",\n                \"Discuss fluoride treatment options with your dentist\"\n            ])\n        \n        if results['yellowness_score'] > 30:\n            professional_care.append(\"Consult with dentist about professional whitening treatments\")\n        \n        if results['alignment_score'] < 55:\n            professional_care.append(\"Schedule orthodontic consultation for alignment evaluation\")\n        elif results['alignment_score'] < 70:\n            professional_care.append(\"Discuss alignment concerns with your dentist\")\n        \n        # Add general professional care\n        professional_care.extend([\n            \"Schedule dental cleanings every 6 months\",\n            \"Annual comprehensive dental examination\"\n        ])\n        \n        recommendations[\"Professional Care\"] = professional_care\n        \n        # Lifestyle recommendations\n        lifestyle = [\n            \"Maintain a balanced diet low in sugary snacks and acidic foods\",\n            \"Stay hydrated throughout the day to promote saliva production\",\n            \"Avoid using teeth as tools (opening packages, biting nails, etc.)\",\n            \"Replace toothbrush every 3-4 months or when bristles fray\"\n        ]\n        \n        if results['cavity_score'] > 10:\n            lifestyle.extend([\n                \"Reduce frequency of sugary snacks between meals\",\n                \"Choose sugar-free gum with xylitol after meals\"\n            ])\n        \n        recommendations[\"Lifestyle Adjustments\"] = lifestyle\n        \n        return recommendations\n","size_bytes":19242},"app_base.py":{"content":"import streamlit as st\nimport cv2\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport base64\nfrom io import BytesIO\nimport json\nimport os\nfrom image_analyzer import TeethAnalyzer\nfrom report_generator import ReportGenerator\nfrom database import Database\n\n# Initialize components\nif 'analyzer' not in st.session_state:\n    st.session_state.analyzer = TeethAnalyzer()\n    st.session_state.report_gen = ReportGenerator()\n    st.session_state.db = Database()\n\n# Initialize session state\nif 'current_screen' not in st.session_state:\n    st.session_state.current_screen = 'home'\nif 'kid_mode' not in st.session_state:\n    st.session_state.kid_mode = False\nif 'current_image' not in st.session_state:\n    st.session_state.current_image = None\nif 'analysis_results' not in st.session_state:\n    st.session_state.analysis_results = None\nif 'user_rewards' not in st.session_state:\n    progress = st.session_state.db.get_user_progress()\n    st.session_state.user_rewards = {'stars': progress['stars'], 'coins': progress['coins']}\n\ndef main():\n    # Configure page\n    st.set_page_config(\n        page_title=\" ToothCheck\",\n        page_icon=\"\",\n        layout=\"wide\"\n    )\n\n    # Mode toggle in sidebar\n    with st.sidebar:\n        st.title(\" ToothCheck\")\n        mode_changed = st.toggle(\"Kid Mode \", value=st.session_state.kid_mode)\n        if mode_changed != st.session_state.kid_mode:\n            st.session_state.kid_mode = mode_changed\n            st.rerun()\n        \n        # Navigation\n        st.markdown(\"---\")\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n        if st.button(\" Scan Teeth\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.rerun()\n        if st.button(\" Progress\", use_container_width=True):\n            st.session_state.current_screen = 'progress'\n            st.rerun()\n\n    # Apply mode-specific styling\n    if st.session_state.kid_mode:\n        st.markdown(\"\"\"\n        <style>\n        .main > div {\n            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);\n        }\n        </style>\n        \"\"\", unsafe_allow_html=True)\n\n    # Route to appropriate screen\n    if st.session_state.current_screen == 'home':\n        show_home_screen()\n    elif st.session_state.current_screen == 'camera':\n        show_camera_screen()\n    elif st.session_state.current_screen == 'quality_check':\n        show_quality_check_screen()\n    elif st.session_state.current_screen == 'analysis':\n        show_analysis_screen()\n    elif st.session_state.current_screen == 'results':\n        show_results_screen()\n    elif st.session_state.current_screen == 'progress':\n        show_progress_screen()\n\ndef show_home_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Welcome to ToothCheck! \")\n        st.markdown(\"###  Keep your smile sparkling bright! \")\n        \n        col1, col2, col3 = st.columns([1, 2, 1])\n        with col2:\n            st.markdown(\"## \")\n        \n        # Kid-friendly buttons\n        col1, col2 = st.columns(2)\n        with col1:\n            if st.button(\" Scan My Teeth! \", use_container_width=True, type=\"primary\"):\n                st.session_state.current_screen = 'camera'\n                st.rerun()\n        with col2:\n            if st.button(\" My Progress! \", use_container_width=True):\n                st.session_state.current_screen = 'progress'\n                st.rerun()\n        \n        # Show rewards\n        st.markdown(\"---\")\n        col1, col2 = st.columns(2)\n        with col1:\n            st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n        with col2:\n            st.metric(\" Coins Collected\", st.session_state.user_rewards['coins'])\n            \n    else:\n        st.markdown(\"#  ToothCheck - Professional Oral Health Screening\")\n        st.markdown(\"### Advanced teeth analysis using computer vision\")\n        \n        # Professional layout\n        col1, col2 = st.columns([2, 1])\n        with col1:\n            st.markdown(\"\"\"\n            **ToothCheck** provides comprehensive oral health analysis by detecting:\n            -  Yellow stains and discoloration\n            -  Possible cavities and dark spots  \n            -  Teeth alignment issues\n            \n            Get your personalized oral health score with actionable recommendations.\n            \"\"\")\n            \n            col_a, col_b = st.columns(2)\n            with col_a:\n                if st.button(\" Start Scan\", use_container_width=True, type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.rerun()\n            with col_b:\n                if st.button(\" View Progress\", use_container_width=True):\n                    st.session_state.current_screen = 'progress'\n                    st.rerun()\n        \n        with col2:\n            # Recent stats if available\n            recent_scans = st.session_state.db.get_recent_scans(5)\n            if recent_scans:\n                st.markdown(\"**Recent Scans**\")\n                for scan in recent_scans:\n                    st.metric(\n                        f\"Health Score ({scan['date']})\", \n                        f\"{scan['overall_score']:.0f}/100\"\n                    )\n\ndef show_camera_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Time for a Tooth Photo! \")\n        st.markdown(\"###  Show me your beautiful smile! \")\n    else:\n        st.markdown(\"#  Capture Image for Analysis\")\n        st.markdown(\"### Position your mouth within the guide for optimal results\")\n\n    # Instructions\n    with st.expander(\" Photo Instructions\", expanded=True):\n        st.markdown(\"\"\"\n        **For best results:**\n        -  Ensure good lighting (natural light preferred)\n        -  Open your mouth and show your teeth clearly\n        -  Hold camera steady and avoid blur\n        -  Center your mouth within the oval guide\n        \"\"\")\n\n    # Camera options\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"** Take Photo**\")\n        camera_image = st.camera_input(\"Capture your smile\")\n        if camera_image:\n            st.session_state.current_image = camera_image\n            st.success(\" Photo captured!\")\n    \n    with col2:\n        st.markdown(\"** Upload Photo**\")\n        uploaded_file = st.file_uploader(\"Choose image\", type=['png', 'jpg', 'jpeg'])\n        if uploaded_file:\n            st.session_state.current_image = uploaded_file\n            st.success(\" Image uploaded!\")\n\n    # Show preview and continue button\n    if st.session_state.current_image:\n        st.markdown(\"---\")\n        st.markdown(\"**Preview:**\")\n        \n        # Display image with oval overlay guide\n        image = Image.open(st.session_state.current_image)\n        fig, ax = plt.subplots(1, 1, figsize=(8, 6))\n        ax.imshow(image)\n        ax.set_title(\"Image Preview with Guide\")\n        \n        # Draw oval guide\n        from matplotlib.patches import Ellipse\n        height, width = image.height, image.width\n        oval = Ellipse((width/2, height/2), width*0.6, height*0.4, \n                      fill=False, color='lime', linewidth=3, linestyle='--')\n        ax.add_patch(oval)\n        ax.text(width/2, height*0.1, \"Position mouth within green guide\", \n                ha='center', color='lime', fontsize=12, weight='bold')\n        ax.axis('off')\n        \n        st.pyplot(fig)\n        plt.close()\n        \n        if st.button(\" Continue to Analysis\", type=\"primary\", use_container_width=True):\n            st.session_state.current_screen = 'quality_check'\n            st.rerun()\n\ndef show_quality_check_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Checking Your Photo! \")\n        st.markdown(\"### Making sure everything looks perfect! \")\n    else:\n        st.markdown(\"#  Image Quality Validation\")\n        st.markdown(\"### Ensuring optimal conditions for accurate analysis\")\n\n    if st.session_state.current_image:\n        # Convert to OpenCV format\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Perform quality checks\n        with st.spinner(\"Checking image quality...\"):\n            quality_results = st.session_state.analyzer.check_image_quality(img_array)\n        \n        # Display results\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            if quality_results['lighting_ok']:\n                st.success(\" Lighting: Good\")\n            else:\n                st.warning(\" Lighting: Needs improvement\")\n        \n        with col2:\n            if quality_results['blur_ok']:\n                st.success(\" Sharpness: Clear\")\n            else:\n                st.warning(\" Sharpness: Too blurry\")\n        \n        with col3:\n            if quality_results['framing_ok']:\n                st.success(\" Framing: Well positioned\")\n            else:\n                st.warning(\" Framing: Reposition mouth\")\n\n        # Decision based on quality\n        all_good = all(quality_results.values())\n        \n        if all_good:\n            if st.session_state.kid_mode:\n                st.success(\" Perfect! Your photo looks amazing! \")\n            else:\n                st.success(\" Image quality validated - proceeding to analysis\")\n            \n            if st.button(\" Start Analysis\", type=\"primary\", use_container_width=True):\n                st.session_state.current_screen = 'analysis'\n                st.rerun()\n        else:\n            if st.session_state.kid_mode:\n                st.warning(\" Oops! Let's try again with better light and a steady hand!\")\n            else:\n                st.warning(\" Image quality issues detected. Please retake photo for better results.\")\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                if st.button(\" Retake Photo\", type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.session_state.current_image = None\n                    st.rerun()\n            with col2:\n                if st.button(\" Analyze Anyway\"):\n                    st.session_state.current_screen = 'analysis'\n                    st.rerun()\n\ndef show_analysis_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Analyzing Your Smile! \")\n        st.markdown(\"### The magic is happening... \")\n    else:\n        st.markdown(\"#  Processing Image Analysis\")\n        st.markdown(\"### Performing comprehensive teeth evaluation\")\n\n    if st.session_state.current_image:\n        # Progress indicator\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        \n        # Convert image\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Analysis steps\n        steps = [\n            (\"Preprocessing image...\", 0.2),\n            (\"Detecting teeth region...\", 0.4),\n            (\"Analyzing yellowness...\", 0.6),\n            (\"Checking for cavities...\", 0.8),\n            (\"Evaluating alignment...\", 1.0)\n        ]\n        \n        for step_text, progress in steps:\n            status_text.text(step_text)\n            progress_bar.progress(progress)\n            \n            # Simulate processing time\n            import time\n            time.sleep(0.5)\n        \n        # Perform actual analysis\n        with st.spinner(\"Finalizing analysis...\"):\n            results = st.session_state.analyzer.analyze_teeth(img_array)\n        \n        st.session_state.analysis_results = results\n        \n        # Success message\n        if st.session_state.kid_mode:\n            st.success(\" Analysis complete! Let's see how your teeth are doing! \")\n        else:\n            st.success(\" Analysis completed successfully\")\n        \n        # Auto-redirect to results\n        import time\n        time.sleep(1)\n        st.session_state.current_screen = 'results'\n        st.rerun()\n\ndef show_results_screen():\n    if not st.session_state.analysis_results:\n        st.error(\"No analysis results found. Please scan your teeth first.\")\n        return\n\n    results = st.session_state.analysis_results\n    \n    if st.session_state.kid_mode:\n        show_kid_results(results)\n    else:\n        show_adult_results(results)\n    \n    # Save results to database and update rewards\n    st.session_state.db.save_scan_results(results)\n    \n    # Update rewards in database\n    if st.session_state.kid_mode:\n        overall_score = results['overall_score']\n        if overall_score >= 80:\n            stars_earned = 3\n            coins_earned = 10\n        elif overall_score >= 60:\n            stars_earned = 2\n            coins_earned = 5\n        else:\n            stars_earned = 1\n            coins_earned = 2\n        \n        st.session_state.db.update_user_rewards(stars_earned, coins_earned)\n\ndef show_kid_results(results):\n    st.markdown(\"#  Your Tooth Report! \")\n    \n    # Overall score with fun animation\n    overall_score = results['overall_score']\n    \n    col1, col2, col3 = st.columns([1, 2, 1])\n    with col2:\n        if overall_score >= 80:\n            st.markdown(\"##  Awesome! Great job! \")\n        elif overall_score >= 60:\n            st.markdown(\"##  Good work! Let's improve! \")\n        else:\n            st.markdown(\"##  Time for extra care! \")\n    \n    # Fun metrics\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        st.metric(\" Health Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n    with col3:\n        st.metric(\" Coins Earned\", st.session_state.user_rewards['coins'])\n    \n    # Show analyzed image\n    st.markdown(\"###  Your Teeth Analysis\")\n    analyzed_img = st.session_state.analyzer.create_visual_overlay(\n        np.array(Image.open(st.session_state.current_image)), results)\n    st.image(analyzed_img, caption=\"Your teeth with colorful markings!\", use_container_width=True)\n    \n    # Kid-friendly tips\n    st.markdown(\"###  Super Tips for You! \")\n    tips = generate_kid_tips(results)\n    for tip in tips:\n        st.markdown(f\" {tip}\")\n    \n    # Action buttons\n    col1, col2 = st.columns(2)\n    with col1:\n        if st.button(\" Go Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col2:\n        if st.button(\" Scan Again\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_adult_results(results):\n    st.markdown(\"#  Comprehensive Oral Health Analysis\")\n    \n    # Overall score\n    overall_score = results['overall_score']\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Overall Health Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        st.metric(\"Whiteness Level\", f\"{100-results['yellowness_score']:.0f}/100\")\n    with col3:\n        st.metric(\"Cavity Health\", f\"{100-results['cavity_score']:.0f}/100\")\n    with col4:\n        st.metric(\"Alignment Score\", f\"{results['alignment_score']:.0f}/100\")\n    \n    # Visual analysis\n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        st.markdown(\"###  Visual Analysis\")\n        analyzed_img = st.session_state.analyzer.create_visual_overlay(\n            np.array(Image.open(st.session_state.current_image)), results)\n        st.image(analyzed_img, caption=\"Detected issues marked with overlays\", use_container_width=True)\n        \n        # Legend\n        st.markdown(\"\"\"\n        **Legend:**\n        -  Yellow overlay: Staining detected\n        -  Red circles: Potential cavities\n        -  Blue outlines: Alignment issues\n        \"\"\")\n    \n    with col2:\n        # Score breakdown chart\n        st.markdown(\"###  Score Breakdown\")\n        \n        categories = ['Whiteness', 'Cavity Health', 'Alignment']\n        scores = [\n            100 - results['yellowness_score'],\n            100 - results['cavity_score'],\n            results['alignment_score']\n        ]\n        \n        fig = go.Figure(data=go.Bar(x=categories, y=scores, \n                                   marker_color=['gold', 'lightcoral', 'lightblue']))\n        fig.update_layout(title=\"Health Metrics\", yaxis_range=[0, 100], height=300)\n        st.plotly_chart(fig, use_container_width=True)\n    \n    # Personalized recommendations\n    st.markdown(\"###  Personalized Recommendations\")\n    tips = generate_adult_tips(results)\n    for i, tip in enumerate(tips, 1):\n        st.markdown(f\"{i}. {tip}\")\n    \n    # Action buttons\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        if st.button(\" Generate PDF Report\", use_container_width=True):\n            with st.spinner(\"Generating PDF report...\"):\n                pdf_data = st.session_state.report_gen.generate_pdf_report(\n                    st.session_state.current_image, results)\n            st.download_button(\n                label=\" Download PDF\",\n                data=pdf_data,\n                file_name=f\"toothcheck_report_{datetime.now().strftime('%Y%m%d')}.pdf\",\n                mime=\"application/pdf\",\n                use_container_width=True\n            )\n    with col2:\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col3:\n        if st.button(\" New Scan\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_progress_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  My Progress Journey! \")\n        st.markdown(\"### Look how awesome you're doing! \")\n    else:\n        st.markdown(\"#  Progress Tracker\")\n        st.markdown(\"### Historical analysis and trends\")\n\n    # Get historical data\n    scans = st.session_state.db.get_all_scans()\n    \n    if not scans:\n        if st.session_state.kid_mode:\n            st.info(\" No scans yet! Take your first photo to start your journey! \")\n        else:\n            st.info(\" No historical data available. Complete your first scan to track progress.\")\n        return\n    \n    # Convert to DataFrame for easier plotting\n    df = pd.DataFrame(scans)\n    df['date'] = pd.to_datetime(df['date'])\n    \n    if st.session_state.kid_mode:\n        # Kid-friendly progress view\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.metric(\" Total Scans\", len(scans))\n            st.metric(\" Total Stars\", st.session_state.user_rewards['stars'])\n        \n        with col2:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\" Latest Score\", f\"{latest_score:.0f}/100\")\n            st.metric(\" Total Coins\", st.session_state.user_rewards['coins'])\n        \n        # Simple progress chart\n        st.markdown(\"###  Your Progress Chart! \")\n        fig = px.line(df, x='date', y='overall_score', \n                     title=\"How Your Teeth Health is Improving! \",\n                     color_discrete_sequence=['#FF6B6B'])\n        fig.update_layout(\n            xaxis_title=\"Date \",\n            yaxis_title=\"Health Score \",\n            yaxis_range=[0, 100]\n        )\n        st.plotly_chart(fig, use_container_width=True)\n        \n    else:\n        # Professional progress view\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Total Scans\", len(scans))\n        with col2:\n            avg_score = df['overall_score'].mean()\n            st.metric(\"Average Score\", f\"{avg_score:.1f}/100\")\n        with col3:\n            if len(df) >= 2:\n                improvement = df['overall_score'].iloc[-1] - df['overall_score'].iloc[-2]\n                st.metric(\"Score Change\", f\"{improvement:+.1f}\", delta=f\"{improvement:.1f}\")\n            else:\n                st.metric(\"Score Change\", \"N/A\")\n        with col4:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\"Latest Score\", f\"{latest_score:.1f}/100\")\n        \n        # Detailed charts\n        tab1, tab2, tab3 = st.tabs([\" Overall Trends\", \" Detailed Metrics\", \" Scan History\"])\n        \n        with tab1:\n            # Overall score trend\n            fig = px.line(df, x='date', y='overall_score', \n                         title=\"Overall Health Score Trend\",\n                         color_discrete_sequence=['#2E86C1'])\n            fig.update_layout(yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab2:\n            # Multi-metric chart\n            fig = go.Figure()\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['yellowness_score'], \n                                   name='Whiteness', line_color='gold'))\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['cavity_score'], \n                                   name='Cavity Health', line_color='lightcoral'))\n            fig.add_trace(go.Scatter(x=df['date'], y=df['alignment_score'], \n                                   name='Alignment', line_color='lightblue'))\n            fig.update_layout(title=\"Detailed Health Metrics\", yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab3:\n            # Scan history table\n            st.markdown(\"**Recent Scan History**\")\n            for scan in scans[-10:]:\n                col1, col2, col3 = st.columns([2, 1, 1])\n                with col1:\n                    st.text(scan['date'])\n                with col2:\n                    st.text(f\"Score: {scan['overall_score']:.0f}/100\")\n                with col3:\n                    if scan['overall_score'] >= 80:\n                        st.text(\" Excellent\")\n                    elif scan['overall_score'] >= 60:\n                        st.text(\" Good\")\n                    else:\n                        st.text(\" Needs Care\")\n\ndef generate_kid_tips(results):\n    tips = []\n    \n    if results['yellowness_score'] > 20:\n        tips.append(\" Try brushing your teeth extra well tonight! \")\n        tips.append(\" Drink more water and less sugary drinks! \")\n    else:\n        tips.append(\" Your teeth are nice and white! Keep it up!\")\n    \n    if results['cavity_score'] > 15:\n        tips.append(\" Eat healthy snacks like apples and carrots! \")\n        tips.append(\" Ask a grown-up to schedule a dentist visit! \")\n    else:\n        tips.append(\" Great job keeping cavities away!\")\n    \n    if results['alignment_score'] < 70:\n        tips.append(\" Keep smiling and practice good posture! \")\n    else:\n        tips.append(\" Your teeth alignment looks great!\")\n    \n    tips.append(\" Remember to brush twice a day for 2 minutes!\")\n    \n    return tips\n\ndef generate_adult_tips(results):\n    tips = []\n    \n    if results['yellowness_score'] > 30:\n        tips.append(\"Consider professional teeth whitening treatment\")\n        tips.append(\"Reduce consumption of coffee, tea, and red wine\")\n        tips.append(\"Use whitening toothpaste as part of daily routine\")\n    elif results['yellowness_score'] > 15:\n        tips.append(\"Monitor staining and consider whitening toothpaste\")\n        tips.append(\"Rinse mouth with water after consuming staining foods\")\n    else:\n        tips.append(\"Excellent whiteness! Maintain current oral hygiene routine\")\n    \n    if results['cavity_score'] > 20:\n        tips.append(\"Schedule immediate dental examination for dark spots\")\n        tips.append(\"Increase flossing frequency to daily\")\n        tips.append(\"Consider fluoride treatments with your dentist\")\n    elif results['cavity_score'] > 10:\n        tips.append(\"Monitor dark spots and maintain regular dental checkups\")\n        tips.append(\"Ensure thorough brushing twice daily\")\n    else:\n        tips.append(\"Low cavity risk detected - keep up good oral hygiene\")\n    \n    if results['alignment_score'] < 60:\n        tips.append(\"Consult an orthodontist for alignment evaluation\")\n        tips.append(\"Consider orthodontic treatment options\")\n    elif results['alignment_score'] < 80:\n        tips.append(\"Minor alignment irregularities detected - monitor progress\")\n    else:\n        tips.append(\"Excellent teeth alignment\")\n    \n    tips.append(\"Schedule dental cleanings every 6 months\")\n    tips.append(\"Replace toothbrush every 3-4 months\")\n    \n    return tips\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":25112},"app.py":{"content":"import streamlit as st\nimport cv2\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport base64\nfrom io import BytesIO\nimport json\nimport os\nfrom image_analyzer import TeethAnalyzer\nfrom report_generator import ReportGenerator\nfrom database import Database\n\n# Initialize components\nif 'analyzer' not in st.session_state:\n    st.session_state.analyzer = TeethAnalyzer()\n    st.session_state.report_gen = ReportGenerator()\n    st.session_state.db = Database()\n\n# Initialize session state\nif 'current_screen' not in st.session_state:\n    st.session_state.current_screen = 'home'\nif 'kid_mode' not in st.session_state:\n    st.session_state.kid_mode = False\nif 'current_image' not in st.session_state:\n    st.session_state.current_image = None\nif 'analysis_results' not in st.session_state:\n    st.session_state.analysis_results = None\nif 'user_rewards' not in st.session_state:\n    progress = st.session_state.db.get_user_progress()\n    st.session_state.user_rewards = {'stars': progress['stars'], 'coins': progress['coins']}\n\ndef main():\n    # Configure page\n    st.set_page_config(\n        page_title=\" Smilo - Smile Analysis\",\n        page_icon=\"\",\n        layout=\"wide\"\n    )\n\n    # Custom CSS for better UI\n    st.markdown(\"\"\"\n    <style>\n    .main {\n        background-color: #f8f9fa;\n    }\n    .stButton>button {\n        border-radius: 10px;\n        font-weight: 600;\n    }\n    .stMetric {\n        background-color: white;\n        padding: 15px;\n        border-radius: 10px;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n    }\n    h1 {\n        color: #4A90E2;\n    }\n    h2, h3 {\n        color: #2C3E50;\n    }\n    </style>\n    \"\"\", unsafe_allow_html=True)\n\n    # Mode toggle in sidebar\n    with st.sidebar:\n        st.title(\" Smilo\")\n        st.markdown(\"### Your Smile Companion\")\n        mode_changed = st.toggle(\"Kid Mode \", value=st.session_state.kid_mode)\n        if mode_changed != st.session_state.kid_mode:\n            st.session_state.kid_mode = mode_changed\n            st.rerun()\n        \n        # Navigation\n        st.markdown(\"---\")\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n        if st.button(\" Scan Smile\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.rerun()\n        if st.button(\" Progress\", use_container_width=True):\n            st.session_state.current_screen = 'progress'\n            st.rerun()\n        \n        # Footer\n        st.markdown(\"---\")\n        st.markdown(\"**Version 2.0**\")\n        st.markdown(\"*Powered by AI*\")\n\n    # Apply mode-specific styling\n    if st.session_state.kid_mode:\n        st.markdown(\"\"\"\n        <style>\n        .main {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n        }\n        </style>\n        \"\"\", unsafe_allow_html=True)\n\n    # Route to appropriate screen\n    if st.session_state.current_screen == 'home':\n        show_home_screen()\n    elif st.session_state.current_screen == 'camera':\n        show_camera_screen()\n    elif st.session_state.current_screen == 'quality_check':\n        show_quality_check_screen()\n    elif st.session_state.current_screen == 'analysis':\n        show_analysis_screen()\n    elif st.session_state.current_screen == 'results':\n        show_results_screen()\n    elif st.session_state.current_screen == 'progress':\n        show_progress_screen()\n\ndef show_home_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Welcome to Smilo! \")\n        st.markdown(\"###  Keep your smile bright and healthy! \")\n        \n        col1, col2, col3 = st.columns([1, 2, 1])\n        with col2:\n            st.markdown(\"## \")\n        \n        # Kid-friendly buttons\n        col1, col2 = st.columns(2)\n        with col1:\n            if st.button(\" Scan My Smile! \", use_container_width=True, type=\"primary\"):\n                st.session_state.current_screen = 'camera'\n                st.rerun()\n        with col2:\n            if st.button(\" My Progress! \", use_container_width=True):\n                st.session_state.current_screen = 'progress'\n                st.rerun()\n        \n        # Show rewards\n        st.markdown(\"---\")\n        col1, col2 = st.columns(2)\n        with col1:\n            st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n        with col2:\n            st.metric(\" Coins Collected\", st.session_state.user_rewards['coins'])\n            \n    else:\n        st.markdown(\"#  Smilo - Professional Smile Analysis\")\n        st.markdown(\"### Advanced dental health screening using AI-powered computer vision\")\n        \n        # Professional layout\n        col1, col2 = st.columns([2, 1])\n        with col1:\n            st.markdown(\"\"\"\n            **Smilo** provides comprehensive oral health analysis by detecting:\n            -  Staining and discoloration levels\n            -  Potential cavities and dark spots  \n            -  Teeth alignment quality\n            \n            Get your personalized smile score with evidence-based recommendations.\n            \"\"\")\n            \n            col_a, col_b = st.columns(2)\n            with col_a:\n                if st.button(\" Start Scan\", use_container_width=True, type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.rerun()\n            with col_b:\n                if st.button(\" View Progress\", use_container_width=True):\n                    st.session_state.current_screen = 'progress'\n                    st.rerun()\n        \n        with col2:\n            # Recent stats if available\n            recent_scans = st.session_state.db.get_recent_scans(5)\n            if recent_scans:\n                st.markdown(\"**Recent Scans**\")\n                for scan in recent_scans:\n                    st.metric(\n                        f\"Score ({scan['date']})\", \n                        f\"{scan['overall_score']:.0f}/100\"\n                    )\n\ndef show_camera_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Time for a Smile Photo! \")\n        st.markdown(\"###  Show me your amazing smile! \")\n    else:\n        st.markdown(\"#  Capture Image for Analysis\")\n        st.markdown(\"### Position your mouth within the guide for optimal results\")\n\n    # Instructions\n    with st.expander(\" Photo Instructions\", expanded=True):\n        st.markdown(\"\"\"\n        **For best results:**\n        -  Ensure good lighting (natural light preferred)\n        -  Open your mouth and show your teeth clearly\n        -  Hold camera steady and avoid blur\n        -  Center your mouth within the oval guide\n        \"\"\")\n\n    # Camera options\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"** Take Photo**\")\n        camera_image = st.camera_input(\"Capture your smile\")\n        if camera_image:\n            st.session_state.current_image = camera_image\n            st.success(\" Photo captured!\")\n    \n    with col2:\n        st.markdown(\"** Upload Photo**\")\n        uploaded_file = st.file_uploader(\"Choose image\", type=['png', 'jpg', 'jpeg'])\n        if uploaded_file:\n            st.session_state.current_image = uploaded_file\n            st.success(\" Image uploaded!\")\n\n    # Show preview and continue button\n    if st.session_state.current_image:\n        st.markdown(\"---\")\n        st.markdown(\"**Preview:**\")\n        \n        # Display image with oval overlay guide\n        image = Image.open(st.session_state.current_image)\n        fig, ax = plt.subplots(1, 1, figsize=(8, 6))\n        ax.imshow(image)\n        ax.set_title(\"Image Preview with Guide\")\n        \n        # Draw oval guide\n        from matplotlib.patches import Ellipse\n        height, width = image.height, image.width\n        oval = Ellipse((width/2, height/2), width*0.6, height*0.4, \n                      fill=False, color='lime', linewidth=3, linestyle='--')\n        ax.add_patch(oval)\n        ax.text(width/2, height*0.1, \"Position mouth within green guide\", \n                ha='center', color='lime', fontsize=12, weight='bold')\n        ax.axis('off')\n        \n        st.pyplot(fig)\n        plt.close()\n        \n        if st.button(\" Continue to Analysis\", type=\"primary\", use_container_width=True):\n            st.session_state.current_screen = 'quality_check'\n            st.rerun()\n\ndef show_quality_check_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Checking Your Photo! \")\n        st.markdown(\"### Making sure everything looks perfect! \")\n    else:\n        st.markdown(\"#  Image Quality Validation\")\n        st.markdown(\"### Ensuring optimal conditions for accurate analysis\")\n\n    if st.session_state.current_image:\n        # Convert to OpenCV format\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Perform quality checks\n        with st.spinner(\"Checking image quality...\"):\n            quality_results = st.session_state.analyzer.check_image_quality(img_array)\n        \n        # Display results\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            if quality_results['lighting_ok']:\n                st.success(\" Lighting: Good\")\n            else:\n                st.warning(\" Lighting: Needs improvement\")\n        \n        with col2:\n            if quality_results['blur_ok']:\n                st.success(\" Sharpness: Clear\")\n            else:\n                st.warning(\" Sharpness: Too blurry\")\n        \n        with col3:\n            if quality_results['framing_ok']:\n                st.success(\" Framing: Well positioned\")\n            else:\n                st.warning(\" Framing: Reposition mouth\")\n\n        # Decision based on quality\n        all_good = all([quality_results['lighting_ok'], quality_results['blur_ok'], quality_results['framing_ok']])\n        \n        if all_good:\n            if st.session_state.kid_mode:\n                st.success(\" Perfect! Your photo looks amazing! \")\n            else:\n                st.success(\" Image quality validated - proceeding to analysis\")\n            \n            if st.button(\" Start Analysis\", type=\"primary\", use_container_width=True):\n                st.session_state.current_screen = 'analysis'\n                st.rerun()\n        else:\n            if st.session_state.kid_mode:\n                st.warning(\" Oops! Let's try again with better light and a steady hand!\")\n            else:\n                st.warning(\" Image quality issues detected. Please retake photo for better results.\")\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                if st.button(\" Retake Photo\", type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.session_state.current_image = None\n                    st.rerun()\n            with col2:\n                if st.button(\" Analyze Anyway\"):\n                    st.session_state.current_screen = 'analysis'\n                    st.rerun()\n\ndef show_analysis_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Analyzing Your Smile! \")\n        st.markdown(\"### The magic is happening... \")\n    else:\n        st.markdown(\"#  Processing Smile Analysis\")\n        st.markdown(\"### Performing comprehensive dental evaluation\")\n\n    if st.session_state.current_image:\n        # Progress indicator\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        \n        # Convert image\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Analysis steps\n        steps = [\n            (\"Preprocessing image...\", 0.2),\n            (\"Detecting teeth region...\", 0.4),\n            (\"Analyzing staining...\", 0.6),\n            (\"Checking for dark spots...\", 0.8),\n            (\"Evaluating alignment...\", 1.0)\n        ]\n        \n        for step_text, progress in steps:\n            status_text.text(step_text)\n            progress_bar.progress(progress)\n            \n            # Simulate processing time\n            import time\n            time.sleep(0.5)\n        \n        # Perform actual analysis\n        with st.spinner(\"Finalizing analysis...\"):\n            results = st.session_state.analyzer.analyze_teeth(img_array)\n        \n        st.session_state.analysis_results = results\n        \n        # Success message\n        if st.session_state.kid_mode:\n            st.success(\" Analysis complete! Let's see how your smile is doing! \")\n        else:\n            st.success(\" Analysis completed successfully\")\n        \n        # Auto-redirect to results\n        import time\n        time.sleep(1)\n        st.session_state.current_screen = 'results'\n        st.rerun()\n\ndef show_results_screen():\n    if not st.session_state.analysis_results:\n        st.error(\"No analysis results found. Please scan your smile first.\")\n        return\n\n    results = st.session_state.analysis_results\n    \n    if st.session_state.kid_mode:\n        show_kid_results(results)\n    else:\n        show_adult_results(results)\n    \n    # Save results to database and update rewards\n    st.session_state.db.save_scan_results(results)\n    \n    # Update rewards in database\n    if st.session_state.kid_mode:\n        overall_score = results['overall_score']\n        if overall_score >= 80:\n            stars_earned = 3\n            coins_earned = 10\n        elif overall_score >= 60:\n            stars_earned = 2\n            coins_earned = 5\n        else:\n            stars_earned = 1\n            coins_earned = 2\n        \n        st.session_state.db.update_user_rewards(stars_earned, coins_earned)\n\ndef show_kid_results(results):\n    st.markdown(\"#  Your Smile Report! \")\n    \n    # Overall score with fun animation\n    overall_score = results['overall_score']\n    \n    col1, col2, col3 = st.columns([1, 2, 1])\n    with col2:\n        if overall_score >= 80:\n            st.markdown(\"##  Awesome! Great job! \")\n        elif overall_score >= 60:\n            st.markdown(\"##  Good work! Let's improve! \")\n        else:\n            st.markdown(\"##  Time for extra care! \")\n    \n    # Fun metrics\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        st.metric(\" Smile Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n    with col3:\n        st.metric(\" Coins Earned\", st.session_state.user_rewards['coins'])\n    \n    # Show analyzed image\n    st.markdown(\"###  Your Smile Analysis\")\n    analyzed_img = st.session_state.analyzer.create_visual_overlay(\n        np.array(Image.open(st.session_state.current_image)), results)\n    st.image(analyzed_img, caption=\"Your teeth with colorful markings!\", use_container_width=True)\n    \n    # Kid-friendly tips\n    st.markdown(\"###  Super Tips for You! \")\n    tips = generate_kid_tips(results)\n    for tip in tips:\n        st.markdown(f\" {tip}\")\n    \n    # Action buttons\n    col1, col2 = st.columns(2)\n    with col1:\n        if st.button(\" Go Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col2:\n        if st.button(\" Scan Again\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_adult_results(results):\n    st.markdown(\"#  Comprehensive Smile Analysis\")\n    \n    # Overall score\n    overall_score = results['overall_score']\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Overall Health Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        whiteness_score = 100 - results['yellowness_score']\n        st.metric(\"Whiteness Level\", f\"{whiteness_score:.0f}/100\")\n        if 'yellowness_severity' in results:\n            severity = results['yellowness_severity']\n            st.markdown(f\"<span style='background-color: {severity['color']}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.75em; font-weight: bold;'>{severity['label']}</span>\", unsafe_allow_html=True)\n    with col3:\n        cavity_health = 100 - results['cavity_score']\n        st.metric(\"Dark Spot Health\", f\"{cavity_health:.0f}/100\")\n        if 'cavity_severity' in results:\n            severity = results['cavity_severity']\n            st.markdown(f\"<span style='background-color: {severity['color']}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.75em; font-weight: bold;'>{severity['label']}</span>\", unsafe_allow_html=True)\n    with col4:\n        st.metric(\"Alignment Score\", f\"{results['alignment_score']:.0f}/100\")\n        if 'alignment_severity' in results:\n            severity = results['alignment_severity']\n            st.markdown(f\"<span style='background-color: {severity['color']}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.75em; font-weight: bold;'>{severity['label']}</span>\", unsafe_allow_html=True)\n    \n    # Visual analysis\n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        st.markdown(\"###  Visual Analysis\")\n        analyzed_img = st.session_state.analyzer.create_visual_overlay(\n            np.array(Image.open(st.session_state.current_image)), results)\n        st.image(analyzed_img, caption=\"Detected issues marked with overlays\", use_container_width=True)\n        \n        # Legend\n        st.markdown(\"\"\"\n        **Legend:**\n        -  Yellow overlay: Staining detected\n        -  Red circles: Potential dark spots/cavities\n        -  Blue outlines: Alignment irregularities\n        \"\"\")\n    \n    with col2:\n        # Score breakdown chart\n        st.markdown(\"###  Score Breakdown\")\n        \n        categories = ['Whiteness', 'Dark Spot\\nHealth', 'Alignment']\n        scores = [\n            100 - results['yellowness_score'],\n            100 - results['cavity_score'],\n            results['alignment_score']\n        ]\n        \n        fig = go.Figure(data=go.Bar(x=categories, y=scores, \n                                   marker_color=['#FFD700', '#FF6B6B', '#4A90E2']))\n        fig.update_layout(title=\"Health Metrics\", yaxis_range=[0, 100], height=300)\n        st.plotly_chart(fig, use_container_width=True)\n    \n    # Personalized recommendations\n    st.markdown(\"###  Personalized Recommendations\")\n    tips = generate_adult_tips(results)\n    for i, tip in enumerate(tips, 1):\n        st.markdown(f\"{i}. {tip}\")\n    \n    # Action buttons\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        if st.button(\" Generate PDF Report\", use_container_width=True):\n            with st.spinner(\"Generating PDF report...\"):\n                pdf_data = st.session_state.report_gen.generate_pdf_report(\n                    st.session_state.current_image, results)\n            st.download_button(\n                label=\" Download PDF\",\n                data=pdf_data,\n                file_name=f\"smilo_report_{datetime.now().strftime('%Y%m%d')}.pdf\",\n                mime=\"application/pdf\",\n                use_container_width=True\n            )\n    with col2:\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col3:\n        if st.button(\" New Scan\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_progress_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  My Progress Journey! \")\n        st.markdown(\"### Look how awesome you're doing! \")\n    else:\n        st.markdown(\"#  Progress Tracker\")\n        st.markdown(\"### Historical analysis and trends\")\n\n    # Get historical data\n    scans = st.session_state.db.get_all_scans()\n    \n    if not scans:\n        if st.session_state.kid_mode:\n            st.info(\" No scans yet! Take your first photo to start your journey! \")\n        else:\n            st.info(\" No historical data available. Complete your first scan to track progress.\")\n        return\n    \n    # Convert to DataFrame for easier plotting\n    df = pd.DataFrame(scans)\n    df['date'] = pd.to_datetime(df['date'])\n    \n    if st.session_state.kid_mode:\n        # Kid-friendly progress view\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.metric(\" Total Scans\", len(scans))\n            st.metric(\" Total Stars\", st.session_state.user_rewards['stars'])\n        \n        with col2:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\" Latest Score\", f\"{latest_score:.0f}/100\")\n            st.metric(\" Total Coins\", st.session_state.user_rewards['coins'])\n        \n        # Simple progress chart\n        st.markdown(\"###  Your Progress Chart! \")\n        fig = px.line(df, x='date', y='overall_score', \n                     title=\"How Your Smile Health is Improving! \",\n                     color_discrete_sequence=['#667eea'])\n        fig.update_layout(\n            xaxis_title=\"Date \",\n            yaxis_title=\"Health Score \",\n            yaxis_range=[0, 100]\n        )\n        st.plotly_chart(fig, use_container_width=True)\n        \n    else:\n        # Professional progress view\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Total Scans\", len(scans))\n        with col2:\n            avg_score = df['overall_score'].mean()\n            st.metric(\"Average Score\", f\"{avg_score:.1f}/100\")\n        with col3:\n            if len(df) >= 2:\n                improvement = df['overall_score'].iloc[-1] - df['overall_score'].iloc[-2]\n                st.metric(\"Score Change\", f\"{improvement:+.1f}\", delta=f\"{improvement:.1f}\")\n            else:\n                st.metric(\"Score Change\", \"N/A\")\n        with col4:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\"Latest Score\", f\"{latest_score:.1f}/100\")\n        \n        # Detailed charts\n        tab1, tab2, tab3 = st.tabs([\" Overall Trends\", \" Detailed Metrics\", \" Scan History\"])\n        \n        with tab1:\n            # Overall score trend\n            fig = px.line(df, x='date', y='overall_score', \n                         title=\"Overall Health Score Trend\",\n                         color_discrete_sequence=['#4A90E2'])\n            fig.update_layout(yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab2:\n            # Multi-metric chart\n            fig = go.Figure()\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['yellowness_score'], \n                                   name='Whiteness', line_color='gold'))\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['cavity_score'], \n                                   name='Dark Spot Health', line_color='lightcoral'))\n            fig.add_trace(go.Scatter(x=df['date'], y=df['alignment_score'], \n                                   name='Alignment', line_color='lightblue'))\n            fig.update_layout(title=\"Detailed Health Metrics\", yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab3:\n            # Scan history table\n            st.markdown(\"**Recent Scan History**\")\n            display_scans = scans[-10:] if len(scans) > 10 else scans\n            display_scans.reverse()\n            \n            for scan in display_scans:\n                col1, col2, col3 = st.columns([2, 1, 1])\n                with col1:\n                    st.text(scan['date'])\n                with col2:\n                    st.text(f\"Score: {scan['overall_score']:.0f}/100\")\n                with col3:\n                    if scan['overall_score'] >= 80:\n                        st.text(\" Excellent\")\n                    elif scan['overall_score'] >= 60:\n                        st.text(\" Good\")\n                    else:\n                        st.text(\" Needs Care\")\n\ndef generate_kid_tips(results):\n    tips = []\n    \n    if results['yellowness_score'] > 25:\n        tips.append(\" Brush your teeth extra well, especially after meals! \")\n        tips.append(\" Drink more water and less sugary drinks! \")\n        tips.append(\" Eat crunchy fruits and veggies to keep teeth clean! \")\n    elif results['yellowness_score'] > 10:\n        tips.append(\" Keep brushing twice a day - you're doing great! \")\n        tips.append(\" Rinse with water after snacks!\")\n    else:\n        tips.append(\" Your teeth are nice and white! Keep it up! \")\n    \n    if results['cavity_score'] > 10:\n        tips.append(\" Eat healthy snacks like apples and carrots! \")\n        tips.append(\" Ask a grown-up to schedule a dentist visit! \")\n        tips.append(\" Make sure to brush all surfaces of your teeth!\")\n    elif results['cavity_score'] > 5:\n        tips.append(\" Good job! Just keep brushing carefully!\")\n    else:\n        tips.append(\" Great job keeping dark spots away! \")\n    \n    if results['alignment_score'] < 70:\n        tips.append(\" Keep smiling and taking care of your teeth! \")\n    else:\n        tips.append(\" Your teeth alignment looks great! \")\n    \n    tips.append(\" Remember to brush twice a day for 2 minutes! \")\n    \n    return tips\n\ndef generate_adult_tips(results):\n    tips = []\n    \n    # Yellowness/whiteness recommendations\n    if results['yellowness_score'] > 40:\n        tips.append(\"Consider professional teeth whitening treatment for best results\")\n        tips.append(\"Significantly reduce consumption of coffee, tea, red wine, and dark sodas\")\n        tips.append(\"Use whitening toothpaste and consider professional dental cleaning\")\n        tips.append(\"Rinse immediately after consuming staining foods or use a straw\")\n    elif results['yellowness_score'] > 25:\n        tips.append(\"Professional whitening treatment recommended for moderate staining\")\n        tips.append(\"Reduce intake of staining beverages and foods\")\n        tips.append(\"Use whitening toothpaste as part of daily routine\")\n    elif results['yellowness_score'] > 10:\n        tips.append(\"Light staining detected - monitor and consider whitening toothpaste\")\n        tips.append(\"Rinse mouth with water after consuming coffee or tea\")\n    else:\n        tips.append(\"Excellent whiteness! Maintain current oral hygiene routine\")\n    \n    # Cavity/dark spot recommendations\n    if results['cavity_score'] > 15:\n        tips.append(\"Schedule dental examination within 1-2 weeks to evaluate dark spots\")\n        tips.append(\"Increase flossing to daily and ensure thorough brushing\")\n        tips.append(\"Reduce sugary snacks between meals\")\n        tips.append(\"Discuss preventive sealants and fluoride treatments with dentist\")\n    elif results['cavity_score'] > 8:\n        tips.append(\"Schedule routine dental checkup to monitor dark areas\")\n        tips.append(\"Maintain thorough brushing twice daily with fluoride toothpaste\")\n        tips.append(\"Ensure daily flossing to remove plaque between teeth\")\n    elif results['cavity_score'] > 2:\n        tips.append(\"Minor dark areas detected - maintain good oral hygiene\")\n        tips.append(\"Continue regular dental checkups every 6 months\")\n    else:\n        tips.append(\"Excellent! No significant dark spots detected - keep up the great work\")\n    \n    # Alignment recommendations\n    if results['alignment_score'] < 55:\n        tips.append(\"Schedule orthodontic consultation for alignment evaluation\")\n        tips.append(\"Discuss treatment options including braces or aligners\")\n    elif results['alignment_score'] < 70:\n        tips.append(\"Minor alignment irregularities - discuss with dentist during checkup\")\n    else:\n        tips.append(\"Excellent teeth alignment\")\n    \n    # General recommendations\n    tips.append(\"Schedule professional dental cleaning every 6 months\")\n    tips.append(\"Replace toothbrush every 3-4 months or when bristles fray\")\n    tips.append(\"Consider an electric toothbrush for more effective cleaning\")\n    \n    return tips\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":28629},"attached_assets/pyproject_1762359913546.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"matplotlib>=3.10.7\",\n    \"numpy>=2.3.4\",\n    \"opencv-python>=4.11.0.86\",\n    \"pandas>=2.3.3\",\n    \"pillow>=12.0.0\",\n    \"plotly>=6.4.0\",\n    \"reportlab>=4.4.4\",\n    \"scikit-image>=0.25.2\",\n    \"streamlit>=1.51.0\",\n]\n","size_bytes":363},"attached_assets/app_1762359913552.py":{"content":"import streamlit as st\nimport cv2\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport base64\nfrom io import BytesIO\nimport json\nimport os\nfrom image_analyzer import TeethAnalyzer\nfrom report_generator import ReportGenerator\nfrom database import Database\n\n# Initialize components\nif 'analyzer' not in st.session_state:\n    st.session_state.analyzer = TeethAnalyzer()\n    st.session_state.report_gen = ReportGenerator()\n    st.session_state.db = Database()\n\n# Initialize session state\nif 'current_screen' not in st.session_state:\n    st.session_state.current_screen = 'home'\nif 'kid_mode' not in st.session_state:\n    st.session_state.kid_mode = False\nif 'current_image' not in st.session_state:\n    st.session_state.current_image = None\nif 'analysis_results' not in st.session_state:\n    st.session_state.analysis_results = None\nif 'user_rewards' not in st.session_state:\n    progress = st.session_state.db.get_user_progress()\n    st.session_state.user_rewards = {'stars': progress['stars'], 'coins': progress['coins']}\n\ndef main():\n    # Configure page\n    st.set_page_config(\n        page_title=\" ToothCheck\",\n        page_icon=\"\",\n        layout=\"wide\"\n    )\n\n    # Mode toggle in sidebar\n    with st.sidebar:\n        st.title(\" ToothCheck\")\n        mode_changed = st.toggle(\"Kid Mode \", value=st.session_state.kid_mode)\n        if mode_changed != st.session_state.kid_mode:\n            st.session_state.kid_mode = mode_changed\n            st.rerun()\n        \n        # Navigation\n        st.markdown(\"---\")\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n        if st.button(\" Scan Teeth\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.rerun()\n        if st.button(\" Progress\", use_container_width=True):\n            st.session_state.current_screen = 'progress'\n            st.rerun()\n\n    # Apply mode-specific styling\n    if st.session_state.kid_mode:\n        st.markdown(\"\"\"\n        <style>\n        .main > div {\n            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);\n        }\n        </style>\n        \"\"\", unsafe_allow_html=True)\n\n    # Route to appropriate screen\n    if st.session_state.current_screen == 'home':\n        show_home_screen()\n    elif st.session_state.current_screen == 'camera':\n        show_camera_screen()\n    elif st.session_state.current_screen == 'quality_check':\n        show_quality_check_screen()\n    elif st.session_state.current_screen == 'analysis':\n        show_analysis_screen()\n    elif st.session_state.current_screen == 'results':\n        show_results_screen()\n    elif st.session_state.current_screen == 'progress':\n        show_progress_screen()\n\ndef show_home_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Welcome to ToothCheck! \")\n        st.markdown(\"###  Keep your smile sparkling bright! \")\n        \n        col1, col2, col3 = st.columns([1, 2, 1])\n        with col2:\n            st.markdown(\"## \")\n        \n        # Kid-friendly buttons\n        col1, col2 = st.columns(2)\n        with col1:\n            if st.button(\" Scan My Teeth! \", use_container_width=True, type=\"primary\"):\n                st.session_state.current_screen = 'camera'\n                st.rerun()\n        with col2:\n            if st.button(\" My Progress! \", use_container_width=True):\n                st.session_state.current_screen = 'progress'\n                st.rerun()\n        \n        # Show rewards\n        st.markdown(\"---\")\n        col1, col2 = st.columns(2)\n        with col1:\n            st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n        with col2:\n            st.metric(\" Coins Collected\", st.session_state.user_rewards['coins'])\n            \n    else:\n        st.markdown(\"#  ToothCheck - Professional Oral Health Screening\")\n        st.markdown(\"### Advanced teeth analysis using computer vision\")\n        \n        # Professional layout\n        col1, col2 = st.columns([2, 1])\n        with col1:\n            st.markdown(\"\"\"\n            **ToothCheck** provides comprehensive oral health analysis by detecting:\n            -  Yellow stains and discoloration\n            -  Possible cavities and dark spots  \n            -  Teeth alignment issues\n            \n            Get your personalized oral health score with actionable recommendations.\n            \"\"\")\n            \n            col_a, col_b = st.columns(2)\n            with col_a:\n                if st.button(\" Start Scan\", use_container_width=True, type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.rerun()\n            with col_b:\n                if st.button(\" View Progress\", use_container_width=True):\n                    st.session_state.current_screen = 'progress'\n                    st.rerun()\n        \n        with col2:\n            # Recent stats if available\n            recent_scans = st.session_state.db.get_recent_scans(5)\n            if recent_scans:\n                st.markdown(\"**Recent Scans**\")\n                for scan in recent_scans:\n                    st.metric(\n                        f\"Health Score ({scan['date']})\", \n                        f\"{scan['overall_score']:.0f}/100\"\n                    )\n\ndef show_camera_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Time for a Tooth Photo! \")\n        st.markdown(\"###  Show me your beautiful smile! \")\n    else:\n        st.markdown(\"#  Capture Image for Analysis\")\n        st.markdown(\"### Position your mouth within the guide for optimal results\")\n\n    # Instructions\n    with st.expander(\" Photo Instructions\", expanded=True):\n        st.markdown(\"\"\"\n        **For best results:**\n        -  Ensure good lighting (natural light preferred)\n        -  Open your mouth and show your teeth clearly\n        -  Hold camera steady and avoid blur\n        -  Center your mouth within the oval guide\n        \"\"\")\n\n    # Camera options\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.markdown(\"** Take Photo**\")\n        camera_image = st.camera_input(\"Capture your smile\")\n        if camera_image:\n            st.session_state.current_image = camera_image\n            st.success(\" Photo captured!\")\n    \n    with col2:\n        st.markdown(\"** Upload Photo**\")\n        uploaded_file = st.file_uploader(\"Choose image\", type=['png', 'jpg', 'jpeg'])\n        if uploaded_file:\n            st.session_state.current_image = uploaded_file\n            st.success(\" Image uploaded!\")\n\n    # Show preview and continue button\n    if st.session_state.current_image:\n        st.markdown(\"---\")\n        st.markdown(\"**Preview:**\")\n        \n        # Display image with oval overlay guide\n        image = Image.open(st.session_state.current_image)\n        fig, ax = plt.subplots(1, 1, figsize=(8, 6))\n        ax.imshow(image)\n        ax.set_title(\"Image Preview with Guide\")\n        \n        # Draw oval guide\n        from matplotlib.patches import Ellipse\n        height, width = image.height, image.width\n        oval = Ellipse((width/2, height/2), width*0.6, height*0.4, \n                      fill=False, color='lime', linewidth=3, linestyle='--')\n        ax.add_patch(oval)\n        ax.text(width/2, height*0.1, \"Position mouth within green guide\", \n                ha='center', color='lime', fontsize=12, weight='bold')\n        ax.axis('off')\n        \n        st.pyplot(fig)\n        plt.close()\n        \n        if st.button(\" Continue to Analysis\", type=\"primary\", use_container_width=True):\n            st.session_state.current_screen = 'quality_check'\n            st.rerun()\n\ndef show_quality_check_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Checking Your Photo! \")\n        st.markdown(\"### Making sure everything looks perfect! \")\n    else:\n        st.markdown(\"#  Image Quality Validation\")\n        st.markdown(\"### Ensuring optimal conditions for accurate analysis\")\n\n    if st.session_state.current_image:\n        # Convert to OpenCV format\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Perform quality checks\n        with st.spinner(\"Checking image quality...\"):\n            quality_results = st.session_state.analyzer.check_image_quality(img_array)\n        \n        # Display results\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            if quality_results['lighting_ok']:\n                st.success(\" Lighting: Good\")\n            else:\n                st.warning(\" Lighting: Needs improvement\")\n        \n        with col2:\n            if quality_results['blur_ok']:\n                st.success(\" Sharpness: Clear\")\n            else:\n                st.warning(\" Sharpness: Too blurry\")\n        \n        with col3:\n            if quality_results['framing_ok']:\n                st.success(\" Framing: Well positioned\")\n            else:\n                st.warning(\" Framing: Reposition mouth\")\n\n        # Decision based on quality\n        all_good = all(quality_results.values())\n        \n        if all_good:\n            if st.session_state.kid_mode:\n                st.success(\" Perfect! Your photo looks amazing! \")\n            else:\n                st.success(\" Image quality validated - proceeding to analysis\")\n            \n            if st.button(\" Start Analysis\", type=\"primary\", use_container_width=True):\n                st.session_state.current_screen = 'analysis'\n                st.rerun()\n        else:\n            if st.session_state.kid_mode:\n                st.warning(\" Oops! Let's try again with better light and a steady hand!\")\n            else:\n                st.warning(\" Image quality issues detected. Please retake photo for better results.\")\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                if st.button(\" Retake Photo\", type=\"primary\"):\n                    st.session_state.current_screen = 'camera'\n                    st.session_state.current_image = None\n                    st.rerun()\n            with col2:\n                if st.button(\" Analyze Anyway\"):\n                    st.session_state.current_screen = 'analysis'\n                    st.rerun()\n\ndef show_analysis_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  Analyzing Your Smile! \")\n        st.markdown(\"### The magic is happening... \")\n    else:\n        st.markdown(\"#  Processing Image Analysis\")\n        st.markdown(\"### Performing comprehensive teeth evaluation\")\n\n    if st.session_state.current_image:\n        # Progress indicator\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        \n        # Convert image\n        image = Image.open(st.session_state.current_image)\n        img_array = np.array(image)\n        \n        # Analysis steps\n        steps = [\n            (\"Preprocessing image...\", 0.2),\n            (\"Detecting teeth region...\", 0.4),\n            (\"Analyzing yellowness...\", 0.6),\n            (\"Checking for cavities...\", 0.8),\n            (\"Evaluating alignment...\", 1.0)\n        ]\n        \n        for step_text, progress in steps:\n            status_text.text(step_text)\n            progress_bar.progress(progress)\n            \n            # Simulate processing time\n            import time\n            time.sleep(0.5)\n        \n        # Perform actual analysis\n        with st.spinner(\"Finalizing analysis...\"):\n            results = st.session_state.analyzer.analyze_teeth(img_array)\n        \n        st.session_state.analysis_results = results\n        \n        # Success message\n        if st.session_state.kid_mode:\n            st.success(\" Analysis complete! Let's see how your teeth are doing! \")\n        else:\n            st.success(\" Analysis completed successfully\")\n        \n        # Auto-redirect to results\n        import time\n        time.sleep(1)\n        st.session_state.current_screen = 'results'\n        st.rerun()\n\ndef show_results_screen():\n    if not st.session_state.analysis_results:\n        st.error(\"No analysis results found. Please scan your teeth first.\")\n        return\n\n    results = st.session_state.analysis_results\n    \n    if st.session_state.kid_mode:\n        show_kid_results(results)\n    else:\n        show_adult_results(results)\n    \n    # Save results to database and update rewards\n    st.session_state.db.save_scan_results(results)\n    \n    # Update rewards in database\n    if st.session_state.kid_mode:\n        overall_score = results['overall_score']\n        if overall_score >= 80:\n            stars_earned = 3\n            coins_earned = 10\n        elif overall_score >= 60:\n            stars_earned = 2\n            coins_earned = 5\n        else:\n            stars_earned = 1\n            coins_earned = 2\n        \n        st.session_state.db.update_user_rewards(stars_earned, coins_earned)\n\ndef show_kid_results(results):\n    st.markdown(\"#  Your Tooth Report! \")\n    \n    # Overall score with fun animation\n    overall_score = results['overall_score']\n    \n    col1, col2, col3 = st.columns([1, 2, 1])\n    with col2:\n        if overall_score >= 80:\n            st.markdown(\"##  Awesome! Great job! \")\n        elif overall_score >= 60:\n            st.markdown(\"##  Good work! Let's improve! \")\n        else:\n            st.markdown(\"##  Time for extra care! \")\n    \n    # Fun metrics\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        st.metric(\" Health Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        st.metric(\" Stars Earned\", st.session_state.user_rewards['stars'])\n    with col3:\n        st.metric(\" Coins Earned\", st.session_state.user_rewards['coins'])\n    \n    # Show analyzed image\n    st.markdown(\"###  Your Teeth Analysis\")\n    analyzed_img = st.session_state.analyzer.create_visual_overlay(\n        np.array(Image.open(st.session_state.current_image)), results)\n    st.image(analyzed_img, caption=\"Your teeth with colorful markings!\", use_container_width=True)\n    \n    # Kid-friendly tips\n    st.markdown(\"###  Super Tips for You! \")\n    tips = generate_kid_tips(results)\n    for tip in tips:\n        st.markdown(f\" {tip}\")\n    \n    # Action buttons\n    col1, col2 = st.columns(2)\n    with col1:\n        if st.button(\" Go Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col2:\n        if st.button(\" Scan Again\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_adult_results(results):\n    st.markdown(\"#  Comprehensive Oral Health Analysis\")\n    \n    # Overall score\n    overall_score = results['overall_score']\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Overall Health Score\", f\"{overall_score:.0f}/100\")\n    with col2:\n        st.metric(\"Whiteness Level\", f\"{100-results['yellowness_score']:.0f}/100\")\n    with col3:\n        st.metric(\"Cavity Health\", f\"{100-results['cavity_score']:.0f}/100\")\n    with col4:\n        st.metric(\"Alignment Score\", f\"{results['alignment_score']:.0f}/100\")\n    \n    # Visual analysis\n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        st.markdown(\"###  Visual Analysis\")\n        analyzed_img = st.session_state.analyzer.create_visual_overlay(\n            np.array(Image.open(st.session_state.current_image)), results)\n        st.image(analyzed_img, caption=\"Detected issues marked with overlays\", use_container_width=True)\n        \n        # Legend\n        st.markdown(\"\"\"\n        **Legend:**\n        -  Yellow overlay: Staining detected\n        -  Red circles: Potential cavities\n        -  Blue outlines: Alignment issues\n        \"\"\")\n    \n    with col2:\n        # Score breakdown chart\n        st.markdown(\"###  Score Breakdown\")\n        \n        categories = ['Whiteness', 'Cavity Health', 'Alignment']\n        scores = [\n            100 - results['yellowness_score'],\n            100 - results['cavity_score'],\n            results['alignment_score']\n        ]\n        \n        fig = go.Figure(data=go.Bar(x=categories, y=scores, \n                                   marker_color=['gold', 'lightcoral', 'lightblue']))\n        fig.update_layout(title=\"Health Metrics\", yaxis_range=[0, 100], height=300)\n        st.plotly_chart(fig, use_container_width=True)\n    \n    # Personalized recommendations\n    st.markdown(\"###  Personalized Recommendations\")\n    tips = generate_adult_tips(results)\n    for i, tip in enumerate(tips, 1):\n        st.markdown(f\"{i}. {tip}\")\n    \n    # Action buttons\n    col1, col2, col3 = st.columns(3)\n    with col1:\n        if st.button(\" Generate PDF Report\", use_container_width=True):\n            with st.spinner(\"Generating PDF report...\"):\n                pdf_data = st.session_state.report_gen.generate_pdf_report(\n                    st.session_state.current_image, results)\n            st.download_button(\n                label=\" Download PDF\",\n                data=pdf_data,\n                file_name=f\"toothcheck_report_{datetime.now().strftime('%Y%m%d')}.pdf\",\n                mime=\"application/pdf\",\n                use_container_width=True\n            )\n    with col2:\n        if st.button(\" Home\", use_container_width=True):\n            st.session_state.current_screen = 'home'\n            st.rerun()\n    with col3:\n        if st.button(\" New Scan\", use_container_width=True):\n            st.session_state.current_screen = 'camera'\n            st.session_state.current_image = None\n            st.session_state.analysis_results = None\n            st.rerun()\n\ndef show_progress_screen():\n    if st.session_state.kid_mode:\n        st.markdown(\"#  My Progress Journey! \")\n        st.markdown(\"### Look how awesome you're doing! \")\n    else:\n        st.markdown(\"#  Progress Tracker\")\n        st.markdown(\"### Historical analysis and trends\")\n\n    # Get historical data\n    scans = st.session_state.db.get_all_scans()\n    \n    if not scans:\n        if st.session_state.kid_mode:\n            st.info(\" No scans yet! Take your first photo to start your journey! \")\n        else:\n            st.info(\" No historical data available. Complete your first scan to track progress.\")\n        return\n    \n    # Convert to DataFrame for easier plotting\n    df = pd.DataFrame(scans)\n    df['date'] = pd.to_datetime(df['date'])\n    \n    if st.session_state.kid_mode:\n        # Kid-friendly progress view\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.metric(\" Total Scans\", len(scans))\n            st.metric(\" Total Stars\", st.session_state.user_rewards['stars'])\n        \n        with col2:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\" Latest Score\", f\"{latest_score:.0f}/100\")\n            st.metric(\" Total Coins\", st.session_state.user_rewards['coins'])\n        \n        # Simple progress chart\n        st.markdown(\"###  Your Progress Chart! \")\n        fig = px.line(df, x='date', y='overall_score', \n                     title=\"How Your Teeth Health is Improving! \",\n                     color_discrete_sequence=['#FF6B6B'])\n        fig.update_layout(\n            xaxis_title=\"Date \",\n            yaxis_title=\"Health Score \",\n            yaxis_range=[0, 100]\n        )\n        st.plotly_chart(fig, use_container_width=True)\n        \n    else:\n        # Professional progress view\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"Total Scans\", len(scans))\n        with col2:\n            avg_score = df['overall_score'].mean()\n            st.metric(\"Average Score\", f\"{avg_score:.1f}/100\")\n        with col3:\n            if len(df) >= 2:\n                improvement = df['overall_score'].iloc[-1] - df['overall_score'].iloc[-2]\n                st.metric(\"Score Change\", f\"{improvement:+.1f}\", delta=f\"{improvement:.1f}\")\n            else:\n                st.metric(\"Score Change\", \"N/A\")\n        with col4:\n            latest_score = df['overall_score'].iloc[-1] if len(df) > 0 else 0\n            st.metric(\"Latest Score\", f\"{latest_score:.1f}/100\")\n        \n        # Detailed charts\n        tab1, tab2, tab3 = st.tabs([\" Overall Trends\", \" Detailed Metrics\", \" Scan History\"])\n        \n        with tab1:\n            # Overall score trend\n            fig = px.line(df, x='date', y='overall_score', \n                         title=\"Overall Health Score Trend\",\n                         color_discrete_sequence=['#2E86C1'])\n            fig.update_layout(yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab2:\n            # Multi-metric chart\n            fig = go.Figure()\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['yellowness_score'], \n                                   name='Whiteness', line_color='gold'))\n            fig.add_trace(go.Scatter(x=df['date'], y=100-df['cavity_score'], \n                                   name='Cavity Health', line_color='lightcoral'))\n            fig.add_trace(go.Scatter(x=df['date'], y=df['alignment_score'], \n                                   name='Alignment', line_color='lightblue'))\n            fig.update_layout(title=\"Detailed Health Metrics\", yaxis_range=[0, 100])\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with tab3:\n            # Scan history table\n            st.markdown(\"**Recent Scan History**\")\n            for scan in scans[-10:]:\n                col1, col2, col3 = st.columns([2, 1, 1])\n                with col1:\n                    st.text(scan['date'])\n                with col2:\n                    st.text(f\"Score: {scan['overall_score']:.0f}/100\")\n                with col3:\n                    if scan['overall_score'] >= 80:\n                        st.text(\" Excellent\")\n                    elif scan['overall_score'] >= 60:\n                        st.text(\" Good\")\n                    else:\n                        st.text(\" Needs Care\")\n\ndef generate_kid_tips(results):\n    tips = []\n    \n    if results['yellowness_score'] > 20:\n        tips.append(\" Try brushing your teeth extra well tonight! \")\n        tips.append(\" Drink more water and less sugary drinks! \")\n    else:\n        tips.append(\" Your teeth are nice and white! Keep it up!\")\n    \n    if results['cavity_score'] > 15:\n        tips.append(\" Eat healthy snacks like apples and carrots! \")\n        tips.append(\" Ask a grown-up to schedule a dentist visit! \")\n    else:\n        tips.append(\" Great job keeping cavities away!\")\n    \n    if results['alignment_score'] < 70:\n        tips.append(\" Keep smiling and practice good posture! \")\n    else:\n        tips.append(\" Your teeth alignment looks great!\")\n    \n    tips.append(\" Remember to brush twice a day for 2 minutes!\")\n    \n    return tips\n\ndef generate_adult_tips(results):\n    tips = []\n    \n    if results['yellowness_score'] > 30:\n        tips.append(\"Consider professional teeth whitening treatment\")\n        tips.append(\"Reduce consumption of coffee, tea, and red wine\")\n        tips.append(\"Use whitening toothpaste as part of daily routine\")\n    elif results['yellowness_score'] > 15:\n        tips.append(\"Monitor staining and consider whitening toothpaste\")\n        tips.append(\"Rinse mouth with water after consuming staining foods\")\n    else:\n        tips.append(\"Excellent whiteness! Maintain current oral hygiene routine\")\n    \n    if results['cavity_score'] > 20:\n        tips.append(\"Schedule immediate dental examination for dark spots\")\n        tips.append(\"Increase flossing frequency to daily\")\n        tips.append(\"Consider fluoride treatments with your dentist\")\n    elif results['cavity_score'] > 10:\n        tips.append(\"Monitor dark spots and maintain regular dental checkups\")\n        tips.append(\"Ensure thorough brushing twice daily\")\n    else:\n        tips.append(\"Low cavity risk detected - keep up good oral hygiene\")\n    \n    if results['alignment_score'] < 60:\n        tips.append(\"Consult an orthodontist for alignment evaluation\")\n        tips.append(\"Consider orthodontic treatment options\")\n    elif results['alignment_score'] < 80:\n        tips.append(\"Minor alignment irregularities detected - monitor progress\")\n    else:\n        tips.append(\"Excellent teeth alignment\")\n    \n    tips.append(\"Schedule dental cleanings every 6 months\")\n    tips.append(\"Replace toothbrush every 3-4 months\")\n    \n    return tips\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":25112},"replit.md":{"content":"# Smilo - Dental Health Analysis Application\n\n## Overview\n\nSmilo is a Streamlit-based web application that performs automated dental health analysis using computer vision. The application allows users to upload teeth images and receive comprehensive analysis reports covering aspects like tooth staining, cavity detection (dark spots), and alignment scoring. It features a dual-mode interface (standard and kid-friendly) with a gamification system that rewards users with stars and coins for regular dental health monitoring.\n\n## Recent Changes (v2.0)\n\n### Branding Update\n- Rebranded from \"ToothCheck\" to \"Smilo\" throughout application\n- Updated color scheme to use #4A90E2 (blue) as primary brand color\n- Modernized UI with improved visual hierarchy and styling\n\n### Critical Bug Fixes\n- **FIXED: Cavity Detection Algorithm** - Previously showing 100% for all scans\n  - Implemented proper brightness-based thresholding\n  - Added circularity filtering to identify actual cavity-like shapes\n  - Limited maximum cavity percentage to realistic 30% cap\n  - Now provides accurate percentage readings (typically 0-15% for healthy teeth)\n\n### Analysis Improvements\n- **Yellowness Detection**: Improved HSV color range calibration with multi-tone stain detection\n- **Whiteness Scoring**: Enhanced with proper contrast normalization and lighting compensation\n- **Alignment Evaluation**: Refined using improved edge detection and symmetry analysis\n- **Overall Scoring**: Better weighted combination of all metrics\n\n### Report Enhancements\n- More accurate personalized reviews based on actual detected metrics\n- Proper interpretation thresholds for each health aspect\n- Evidence-based recommendations scaled to severity\n- PDF reports now branded as \"Smilo\" with updated styling\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n\n**Framework Choice: Streamlit**\n- **Rationale**: Streamlit provides rapid prototyping for data-driven applications with minimal frontend code\n- **Pros**: Fast development, built-in state management, easy data visualization integration\n- **Cons**: Limited customization compared to traditional web frameworks, server-side rendering only\n\n**State Management**\n- Uses Streamlit's native session state for maintaining application state across reruns\n- Key state variables: `current_screen`, `kid_mode`, `current_image`, `analysis_results`, `user_rewards`\n- Component instances (analyzer, report generator, database) are cached in session state for performance\n\n**UI Patterns**\n- Sidebar navigation for mode switching and main controls\n- Wide layout configuration for better image display\n- Dual-mode interface: standard mode for adults, kid mode with simplified language and gamification elements\n- Modern card-based design with shadows and rounded corners\n\n### Backend Architecture\n\n**Modular Component Design**\n- **TeethAnalyzer**: Handles all image processing and analysis logic using OpenCV and scikit-image\n- **ReportGenerator**: Creates PDF reports using ReportLab with custom styling\n- **Database**: Manages data persistence and retrieval operations\n- **Rationale**: Separation of concerns allows independent testing and maintenance of each module\n\n**Image Processing Pipeline**\n- Quality checks (lighting, blur, framing) before analysis\n- Multi-metric analysis system: staining detection, cavity scoring, alignment assessment\n- Uses computer vision techniques: Laplacian variance for blur detection, adaptive/binary thresholding, contrast analysis\n- **Chosen approach**: OpenCV + scikit-image combination provides robust image processing capabilities\n\n**Analysis Scoring System**\n- Individual scores for yellowness (0-100%), cavities (0-30%), and alignment (0-100)\n- Overall composite score calculation with weighted formula\n- Quality thresholds: blur_threshold: 100, brightness range: 50-200\n\n**Key Algorithm Improvements**\n1. **Cavity Detection Fix**:\n   - Dynamic brightness-based thresholding instead of fixed adaptive threshold\n   - Circularity filtering (> 0.3) to identify round cavity-like shapes\n   - Size constraints: 15-800 pixels to filter noise and large shadows\n   - Realistic percentage cap at 30% maximum\n\n2. **Yellowness Detection**:\n   - Dual HSV range detection for different stain tones\n   - LAB color space support for better color accuracy\n   - Expanded detection range: H[10-35], S[20-255], V[100-255]\n\n3. **Alignment Evaluation**:\n   - Improved Canny edge detection parameters (30, 120)\n   - Combined convexity and aspect ratio scoring\n   - Ellipse fitting for ideal alignment comparison\n\n### Data Storage\n\n**Database: SQLite**\n- **Rationale**: Lightweight, serverless, requires no configuration - ideal for single-user desktop/web application\n- **Schema Design**:\n  - `scans`: Stores historical scan data with scores and analysis metadata\n  - `user_progress`: Tracks gamification metrics (stars, coins, total scans)\n  - `reminders`: Manages scheduled dental care reminders\n- **Data Serialization**: JSON format for complex analysis_data storage within SQLite\n- **Database file**: `smilo.db` (changed from toothcheck.db)\n\n**Session State vs Persistent Storage**\n- Transient data (current image, active analysis) stored in Streamlit session state\n- Historical data and user progress persisted to SQLite\n- **Trade-off**: Session state provides fast access but requires database sync for persistence\n\n### Report Generation\n\n**PDF Generation: ReportLab**\n- Custom styled reports with Smilo branding (#4A90E2 theme color)\n- Headers, tables, and embedded images\n- Predefined styles for consistency (CustomTitle, CustomSubtitle, SectionHeader)\n- Support for multiple page sizes (Letter, A4)\n- Accurate interpretations based on actual analysis metrics\n\n### Gamification System\n\n**Reward Mechanism**\n- Stars and coins awarded for scan completions\n- Progress tracking with last_scan_date to encourage regular use\n- Integration with database for persistent reward state\n- **Purpose**: Increase user engagement, particularly effective in kid mode\n\n## External Dependencies\n\n### Core Python Libraries\n\n**Computer Vision & Image Processing**\n- `opencv-python (cv2)`: Primary image processing, quality checks, blur detection\n- `scikit-image`: Advanced morphological operations, filtering, measurements\n- `Pillow (PIL)`: Image format conversions and basic manipulations\n- `numpy`: Array operations and numerical computations for image data\n\n**Visualization**\n- `matplotlib`: Static plot generation for analysis visualizations\n- `plotly`: Interactive charts (express and graph_objects) for progress tracking\n- `streamlit`: Web application framework and UI components\n\n**Report Generation**\n- `reportlab`: PDF creation with custom styling and layouts\n\n**Data Management**\n- `pandas`: Data manipulation for historical scan data and progress tracking\n- `sqlite3`: Built-in Python library for database operations\n\n**Utilities**\n- `datetime`: Timestamp management for scans and reminders\n- `json`: Serialization of complex analysis data\n- `base64`: Image encoding for data transfer\n- `io.BytesIO`: In-memory file operations\n\n### Database\n\n**SQLite (Local File-Based)**\n- Database file: `smilo.db`\n- No external database server required\n- Suitable for single-user deployment\n- Migration path available if multi-user support needed (could migrate to PostgreSQL)\n\n### File System Dependencies\n\n**Local Storage**\n- Temporary image storage during analysis\n- PDF report output location\n- Database file persistence\n- No cloud storage integration in current implementation\n\n## Testing\n\nTo test the application with the included sample image:\n1. Run the application\n2. Navigate to \"Scan Smile\"\n3. Upload `test_image.png`\n4. Verify that cavity detection shows realistic percentages (not 100%)\n5. Check that all metrics display accurately in results\n","size_bytes":7845},"image_analyzer.py":{"content":"import cv2\nimport numpy as np\nfrom PIL import Image\nfrom skimage import filters, morphology, measure\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle, Ellipse\nimport io\n\nclass TeethAnalyzer:\n    def __init__(self):\n        self.blur_threshold = 100\n        self.brightness_min = 50\n        self.brightness_max = 200\n        \n    def check_image_quality(self, img_array):\n        \"\"\"Check image quality for lighting, blur, and framing\"\"\"\n        \n        # Convert to grayscale for analysis\n        if len(img_array.shape) == 3:\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        else:\n            gray = img_array\n            \n        # Check lighting\n        avg_brightness = np.mean(gray)\n        lighting_ok = self.brightness_min < avg_brightness < self.brightness_max\n        \n        # Check blur using Laplacian variance\n        blur_score = cv2.Laplacian(gray, cv2.CV_64F).var()\n        blur_ok = blur_score > self.blur_threshold\n        \n        # Check framing (simplified - check if center region has enough contrast)\n        h, w = gray.shape\n        center_region = gray[h//4:3*h//4, w//4:3*w//4]\n        contrast = np.std(center_region)\n        framing_ok = contrast > 20\n        \n        return {\n            'lighting_ok': lighting_ok,\n            'blur_ok': blur_ok,\n            'framing_ok': framing_ok,\n            'brightness': avg_brightness,\n            'blur_score': blur_score,\n            'contrast': contrast\n        }\n    \n    def classify_severity(self, metric_name, score):\n        \"\"\"\n        Classify severity level for each metric\n        \n        Args:\n            metric_name: 'yellowness', 'cavity', or 'alignment'\n            score: The metric score\n            \n        Returns:\n            dict with severity level and description\n        \"\"\"\n        severity_thresholds = {\n            'yellowness': {\n                'mild': (0, 15),      # 0-15% staining\n                'moderate': (15, 35), # 15-35% staining\n                'severe': (35, 100)   # 35%+ staining\n            },\n            'cavity': {\n                'mild': (0, 5),       # 0-5% dark spots\n                'moderate': (5, 15),  # 5-15% dark spots\n                'severe': (15, 30)    # 15%+ dark spots\n            },\n            'alignment': {\n                # For alignment, score is 0-100, higher is better\n                'mild': (70, 100),    # 70-100 is good alignment\n                'moderate': (50, 70), # 50-70 needs some work\n                'severe': (0, 50)     # 0-50 needs significant work\n            }\n        }\n        \n        thresholds = severity_thresholds.get(metric_name, {})\n        \n        for severity, (min_val, max_val) in thresholds.items():\n            if min_val <= score < max_val or (severity == 'severe' and score >= max_val and metric_name != 'alignment'):\n                return {\n                    'level': severity,\n                    'label': severity.capitalize(),\n                    'color': self.get_severity_color(severity)\n                }\n        \n        # Default to mild if no match\n        return {\n            'level': 'mild',\n            'label': 'Mild',\n            'color': self.get_severity_color('mild')\n        }\n    \n    def get_severity_color(self, severity):\n        \"\"\"Get color code for severity level\"\"\"\n        colors = {\n            'mild': '#27AE60',      # Green\n            'moderate': '#F39C12',  # Orange\n            'severe': '#E74C3C'     # Red\n        }\n        return colors.get(severity, '#95A5A6')\n    \n    def analyze_teeth(self, img_array):\n        \"\"\"Comprehensive teeth analysis with severity classification\"\"\"\n        \n        # Preprocessing\n        processed_img = self.preprocess_image(img_array)\n        \n        # Extract teeth region\n        teeth_mask = self.extract_teeth_region(processed_img)\n        \n        # Perform individual analyses\n        yellowness_score = self.detect_yellowness(processed_img, teeth_mask)\n        cavity_score = self.detect_cavities(processed_img, teeth_mask)\n        alignment_score = self.evaluate_alignment(processed_img, teeth_mask)\n        \n        # Calculate overall score\n        overall_score = self.calculate_overall_score(\n            yellowness_score, cavity_score, alignment_score)\n        \n        # Classify severity for each metric\n        yellowness_severity = self.classify_severity('yellowness', yellowness_score)\n        cavity_severity = self.classify_severity('cavity', cavity_score)\n        alignment_severity = self.classify_severity('alignment', alignment_score)\n        \n        return {\n            'overall_score': overall_score,\n            'yellowness_score': yellowness_score,\n            'yellowness_severity': yellowness_severity,\n            'cavity_score': cavity_score,\n            'cavity_severity': cavity_severity,\n            'alignment_score': alignment_score,\n            'alignment_severity': alignment_severity,\n            'teeth_mask': teeth_mask,\n            'processed_image': processed_img\n        }\n    \n    def preprocess_image(self, img_array):\n        \"\"\"Preprocess image for analysis\"\"\"\n        \n        # Convert to RGB if needed\n        if len(img_array.shape) == 3 and img_array.shape[2] == 3:\n            img_rgb = img_array\n        else:\n            img_rgb = cv2.cvtColor(img_array, cv2.COLOR_BGR2RGB)\n        \n        # Apply CLAHE for contrast enhancement\n        lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)\n        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))\n        lab[:,:,0] = clahe.apply(lab[:,:,0])\n        enhanced = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)\n        \n        # Gamma correction for brightness normalization\n        gamma = 1.2\n        enhanced = np.power(enhanced / 255.0, gamma) * 255.0\n        enhanced = enhanced.astype(np.uint8)\n        \n        return enhanced\n    \n    def extract_teeth_region(self, img_array):\n        \"\"\"Extract teeth region using improved color-based segmentation\"\"\"\n        \n        # Convert to HSV for better color segmentation\n        hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n        \n        # Expanded range for teeth color (white/off-white/cream/light yellow)\n        lower_teeth = np.array([0, 0, 120])\n        upper_teeth = np.array([40, 80, 255])\n        \n        # Create mask for teeth\n        teeth_mask = cv2.inRange(hsv, lower_teeth, upper_teeth)\n        \n        # Morphological operations to clean up mask\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))\n        teeth_mask = cv2.morphologyEx(teeth_mask, cv2.MORPH_OPEN, kernel)\n        teeth_mask = cv2.morphologyEx(teeth_mask, cv2.MORPH_CLOSE, kernel)\n        \n        # Find largest contour (main teeth region)\n        contours, _ = cv2.findContours(teeth_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        if contours:\n            # Get the largest contour\n            largest_contour = max(contours, key=cv2.contourArea)\n            \n            # Create refined mask\n            refined_mask = np.zeros_like(teeth_mask)\n            cv2.fillPoly(refined_mask, [largest_contour], 255)\n            \n            return refined_mask\n        \n        return teeth_mask\n    \n    def detect_yellowness(self, img_array, teeth_mask):\n        \"\"\"Detect yellow staining on teeth with improved color detection\"\"\"\n        \n        # Convert to HSV\n        hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n        \n        # Convert to LAB color space for better yellow detection\n        lab = cv2.cvtColor(img_array, cv2.COLOR_RGB2LAB)\n        \n        # Define multiple yellow/stain color ranges for better detection\n        lower_yellow1 = np.array([18, 40, 100])\n        upper_yellow1 = np.array([35, 255, 255])\n        \n        lower_yellow2 = np.array([10, 20, 120])\n        upper_yellow2 = np.array([25, 100, 220])\n        \n        # Create yellow masks\n        yellow_mask1 = cv2.inRange(hsv, lower_yellow1, upper_yellow1)\n        yellow_mask2 = cv2.inRange(hsv, lower_yellow2, upper_yellow2)\n        \n        # Combine masks\n        yellow_mask = cv2.bitwise_or(yellow_mask1, yellow_mask2)\n        \n        # Combine with teeth mask\n        yellow_on_teeth = cv2.bitwise_and(yellow_mask, teeth_mask)\n        \n        # Calculate yellowness percentage\n        teeth_pixels = np.sum(teeth_mask > 0)\n        yellow_pixels = np.sum(yellow_on_teeth > 0)\n        \n        if teeth_pixels > 0:\n            yellowness_percentage = (yellow_pixels / teeth_pixels) * 100\n        else:\n            yellowness_percentage = 0\n        \n        # Apply a scaling factor to make it more realistic\n        yellowness_percentage = min(yellowness_percentage * 1.2, 100)\n            \n        return min(yellowness_percentage, 100)\n    \n    def detect_cavities(self, img_array, teeth_mask):\n        \"\"\"Detect potential cavities with FIXED algorithm to prevent 100% readings\"\"\"\n        \n        # Convert to grayscale\n        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        \n        # Apply teeth mask\n        masked_gray = cv2.bitwise_and(gray, teeth_mask)\n        \n        # Only process if we have teeth pixels\n        teeth_pixels = np.sum(teeth_mask > 0)\n        if teeth_pixels == 0:\n            return 0\n        \n        # Calculate average brightness of teeth region\n        teeth_region_pixels = gray[teeth_mask > 0]\n        avg_brightness = np.mean(teeth_region_pixels)\n        \n        # Dynamic threshold based on brightness\n        # Lower threshold for darker images, higher for brighter\n        threshold_value = max(30, int(avg_brightness * 0.6))\n        \n        # Use binary threshold instead of adaptive for better control\n        _, binary = cv2.threshold(masked_gray, threshold_value, 255, cv2.THRESH_BINARY_INV)\n        \n        # Remove noise with morphological operations\n        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))\n        cleaned = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)\n        \n        # Find contours of dark spots\n        contours, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        # Filter contours by size and shape (cavity-like dimensions)\n        cavity_contours = []\n        min_area = 15\n        max_area = 800\n        \n        for contour in contours:\n            area = cv2.contourArea(contour)\n            if min_area < area < max_area:\n                # Check circularity to filter out non-cavity shapes\n                perimeter = cv2.arcLength(contour, True)\n                if perimeter > 0:\n                    circularity = 4 * np.pi * area / (perimeter * perimeter)\n                    if circularity > 0.3:\n                        cavity_contours.append(contour)\n        \n        # Calculate cavity risk percentage\n        cavity_pixels = sum([cv2.contourArea(c) for c in cavity_contours])\n        \n        # Calculate percentage with proper scaling\n        cavity_percentage = (cavity_pixels / teeth_pixels) * 100\n        \n        # Cap at reasonable maximum (cavities shouldn't exceed 30% realistically)\n        cavity_percentage = min(cavity_percentage, 30)\n            \n        return cavity_percentage\n    \n    def evaluate_alignment(self, img_array, teeth_mask):\n        \"\"\"Evaluate teeth alignment with improved algorithm\"\"\"\n        \n        # Convert to grayscale\n        gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n        \n        # Apply teeth mask\n        masked_gray = cv2.bitwise_and(gray, teeth_mask)\n        \n        # Find edges of teeth with optimized parameters\n        edges = cv2.Canny(masked_gray, 30, 120)\n        \n        # Find contours\n        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        if not contours:\n            return 50\n        \n        # Get the main teeth contour\n        main_contour = max(contours, key=cv2.contourArea)\n        \n        # Fit an ellipse to the contour to represent ideal alignment\n        if len(main_contour) >= 5:\n            try:\n                ellipse = cv2.fitEllipse(main_contour)\n                \n                # Calculate alignment based on multiple factors\n                hull = cv2.convexHull(main_contour)\n                hull_area = cv2.contourArea(hull)\n                contour_area = cv2.contourArea(main_contour)\n                \n                if hull_area > 0:\n                    convexity = contour_area / hull_area\n                    \n                    # Calculate regularity score based on ellipse fit\n                    _, (width, height), _ = ellipse\n                    aspect_ratio = min(width, height) / max(width, height) if max(width, height) > 0 else 0\n                    \n                    # Combined score\n                    alignment_score = (convexity * 70 + aspect_ratio * 30)\n                else:\n                    alignment_score = 50\n            except:\n                alignment_score = 50\n        else:\n            alignment_score = 50\n            \n        return min(max(alignment_score, 0), 100)\n    \n    def calculate_overall_score(self, yellowness, cavity_risk, alignment):\n        \"\"\"Calculate overall oral health score\"\"\"\n        \n        # Weights for different factors\n        yellowness_weight = 0.3\n        cavity_weight = 0.5\n        alignment_weight = 0.2\n        \n        # Convert scores to positive scale (higher = better)\n        whiteness_score = 100 - yellowness\n        cavity_health_score = 100 - cavity_risk\n        \n        # Weighted average\n        overall = (\n            whiteness_score * yellowness_weight +\n            cavity_health_score * cavity_weight +\n            alignment * alignment_weight\n        )\n        \n        return min(max(overall, 0), 100)\n    \n    def create_visual_overlay(self, img_array, analysis_results):\n        \"\"\"Create visual overlay showing detected issues\"\"\"\n        \n        # Create a copy of the original image\n        overlay_img = img_array.copy()\n        \n        # Create figure for matplotlib overlay\n        fig, ax = plt.subplots(1, 1, figsize=(10, 8))\n        ax.imshow(overlay_img)\n        ax.set_title(\"Smilo Analysis Results\", fontsize=16, fontweight='bold')\n        \n        # Get image dimensions\n        height, width = img_array.shape[:2]\n        \n        # Overlay yellowness (yellow transparent regions)\n        if analysis_results['yellowness_score'] > 10:\n            # Convert to HSV to find yellow regions\n            hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)\n            lower_yellow = np.array([18, 40, 100])\n            upper_yellow = np.array([35, 255, 255])\n            yellow_mask = cv2.inRange(hsv, lower_yellow, upper_yellow)\n            \n            # Apply teeth mask\n            teeth_mask = analysis_results['teeth_mask']\n            yellow_on_teeth = cv2.bitwise_and(yellow_mask, teeth_mask)\n            \n            # Create yellow overlay\n            yellow_overlay = np.zeros_like(overlay_img)\n            yellow_overlay[yellow_on_teeth > 0] = [255, 255, 0]\n            \n            # Blend with original\n            alpha = 0.3\n            overlay_img = cv2.addWeighted(overlay_img, 1-alpha, yellow_overlay, alpha, 0)\n        \n        # Overlay cavity indicators (red circles) - FIXED to show actual cavities\n        if analysis_results['cavity_score'] > 2:\n            # Find dark spots as potential cavities\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n            masked_gray = cv2.bitwise_and(gray, analysis_results['teeth_mask'])\n            \n            # Get average brightness\n            teeth_pixels = gray[analysis_results['teeth_mask'] > 0]\n            if len(teeth_pixels) > 0:\n                avg_brightness = np.mean(teeth_pixels)\n                threshold_value = max(30, int(avg_brightness * 0.6))\n                \n                # Binary threshold\n                _, binary = cv2.threshold(masked_gray, threshold_value, 255, cv2.THRESH_BINARY_INV)\n                \n                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2, 2))\n                cleaned = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)\n                \n                contours, _ = cv2.findContours(cleaned, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n                \n                # Draw circles around potential cavities\n                for contour in contours:\n                    area = cv2.contourArea(contour)\n                    if 15 < area < 800:\n                        perimeter = cv2.arcLength(contour, True)\n                        if perimeter > 0:\n                            circularity = 4 * np.pi * area / (perimeter * perimeter)\n                            if circularity > 0.3:\n                                # Get centroid\n                                M = cv2.moments(contour)\n                                if M[\"m00\"] != 0:\n                                    cx = int(M[\"m10\"] / M[\"m00\"])\n                                    cy = int(M[\"m01\"] / M[\"m00\"])\n                                    \n                                    # Draw circle\n                                    circle = Circle((cx, cy), radius=15, fill=False, \n                                                  color='red', linewidth=3, alpha=0.8)\n                                    ax.add_patch(circle)\n        \n        # Overlay alignment indicators (blue outlines)\n        if analysis_results['alignment_score'] < 80:\n            # Find main teeth contour\n            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)\n            masked_gray = cv2.bitwise_and(gray, analysis_results['teeth_mask'])\n            edges = cv2.Canny(masked_gray, 30, 120)\n            contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n            \n            if contours:\n                main_contour = max(contours, key=cv2.contourArea)\n                \n                # Draw contour outline in blue\n                contour_points = main_contour.reshape(-1, 2)\n                if len(contour_points) > 0:\n                    ax.plot(contour_points[:, 0], contour_points[:, 1], \n                           'b-', linewidth=2, alpha=0.7, label='Alignment Guide')\n        \n        # Add legend\n        legend_elements = []\n        if analysis_results['yellowness_score'] > 10:\n            legend_elements.append(plt.Line2D([0], [0], color='yellow', lw=4, alpha=0.7, label='Staining'))\n        if analysis_results['cavity_score'] > 2:\n            legend_elements.append(plt.Line2D([0], [0], marker='o', color='red', lw=0, \n                                            markersize=10, alpha=0.8, label='Potential Cavities'))\n        if analysis_results['alignment_score'] < 80:\n            legend_elements.append(plt.Line2D([0], [0], color='blue', lw=2, alpha=0.7, label='Alignment Issues'))\n        \n        if legend_elements:\n            ax.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1, 1))\n        \n        # Remove axes\n        ax.axis('off')\n        \n        # Convert matplotlib figure to image\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', dpi=100)\n        plt.close(fig)\n        buf.seek(0)\n        \n        # Convert to PIL Image\n        pil_image = Image.open(buf)\n        \n        return pil_image\n","size_bytes":19233}},"version":2}